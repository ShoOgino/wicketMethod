	private AbstractTree<TreeNode> newTree()
	{
		List<IColumn<TreeNode, Void>> columns = new ArrayList<IColumn<TreeNode, Void>>();
		if (visibleColumns.contains(VisibleColumns.PATH))
		{
			columns.add(new PropertyColumn<TreeNode, Void>(Model.of("Path"), "path")
			{
				private static final long serialVersionUID = 1L;

				@Override
				public String getCssClass()
				{
					return "col_path";
				}
			});
		}
		columns.add(new TreeColumn<TreeNode, Void>(Model.of("Tree")));
		if (visibleColumns.contains(VisibleColumns.STATELESS))
		{
			columns.add(new PropertyColumn<TreeNode, Void>(Model.of("Stateless"), "stateless")
			{
				private static final long serialVersionUID = 1L;

				@Override
				public String getCssClass()
				{
					return "col_stateless";
				}
			});
		}
		if (visibleColumns.contains(VisibleColumns.RENDER_TIME))
		{
			columns.add(new PropertyColumn<TreeNode, Void>(Model.of("Render time (ms)"),
				"renderTime")
			{
				private static final long serialVersionUID = 1L;

				@Override
				public String getCssClass()
				{
					return "col_renderTime";
				}
			});
		}
		if (visibleColumns.contains(VisibleColumns.SIZE))
		{
			columns.add(new AbstractColumn<TreeNode, Void>(Model.of("Size"))
			{
				private static final long serialVersionUID = 1L;

				@Override
				public void populateItem(Item<ICellPopulator<TreeNode>> item, String componentId,
					IModel<TreeNode> rowModel)
				{
					item.add(new Label(componentId, Bytes.bytes(rowModel.getObject().getSize())
						.toString()));
				}

				@Override
				public String getCssClass()
				{
					return "col_size";
				}
			});
		}
		if (visibleColumns.contains(VisibleColumns.TYPE))
		{
			columns.add(new PropertyColumn<TreeNode, Void>(Model.of("Type"), "type"));
		}
		if (visibleColumns.contains(VisibleColumns.MODEL))
		{
			columns.add(new PropertyColumn<TreeNode, Void>(Model.of("Model Object"), "model"));
		}

		TreeProvider provider = new TreeProvider();
		IModel<Set<TreeNode>> expandStateModel = new LoadableDetachableModel<Set<TreeNode>>()
		{
			private static final long serialVersionUID = 1L;

			@Override
			protected Set<TreeNode> load()
			{
				return expandState;
			}
		};
		AbstractTree<TreeNode> tree = new DefaultTableTree<TreeNode, Void>("tree", columns,
			provider, Integer.MAX_VALUE, expandStateModel)
		{
			private static final long serialVersionUID = 1L;

			@Override
			protected Item<TreeNode> newRowItem(String id, int index, IModel<TreeNode> model)
			{
				return new OddEvenItem<TreeNode>(id, index, model);
			}
		};
		tree.setOutputMarkupId(true);
		return tree;
	}

