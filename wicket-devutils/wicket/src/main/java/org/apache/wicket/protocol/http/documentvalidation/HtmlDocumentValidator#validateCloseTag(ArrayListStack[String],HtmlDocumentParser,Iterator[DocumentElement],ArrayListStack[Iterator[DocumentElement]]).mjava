	/**
	 * Validate the close tag that was found.
	 * 
	 * @param tagNameStack
	 *            The stack of tag names
	 * @param parser
	 *            The parser
	 * @param expectedElements
	 *            The current iterator of expected elements
	 * @param iteratorStack
	 *            The stack of previous iterators
	 * @return The next iterator to use, or null
	 */
	private Iterator<DocumentElement> validateCloseTag(ArrayListStack<String> tagNameStack,
		HtmlDocumentParser parser, Iterator<DocumentElement> expectedElements,
		ArrayListStack<Iterator<DocumentElement>> iteratorStack)
	{
		if (tagNameStack.isEmpty())
		{
			log.error("Found closing tag </" + parser.getTag() + "> when there are no " +
				"tags currently open");
			expectedElements = null;
		}
		else
		{
			String expectedTag = tagNameStack.pop();
			if (!expectedTag.equals(parser.getTag()))
			{
				log.error("Found closing tag </" + parser.getTag() + "> when we expecting " +
					"the closing tag </" + expectedTag + "> instead");
				expectedElements = null;
			}
			else
			{
				if (expectedElements.hasNext())
				{
					DocumentElement e = expectedElements.next();
					log.error("Found closing tag </" + parser.getTag() + "> but we were " +
						"expecting to find another child element: " + e.toString());
					expectedElements = null;
				}
				else
				{
					if (iteratorStack.isEmpty())
					{
						log.error("Unexpected parsing error");
						expectedElements = null;
					}
					else
					{
						expectedElements = iteratorStack.pop();
					}
				}
			}
		}
		return expectedElements;
	}

