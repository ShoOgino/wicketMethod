	/**
	 * Sets the converted input, which is an instance of {@link Date}, possibly null. It combines
	 * the inputs of the nested date, hours, minutes and am/pm fields and constructs a date from it.
	 * <p>
	 * Note that overriding this method is a better option than overriding {@link #updateModel()}
	 * like the first versions of this class did. The reason for that is that this method can be
	 * used by form validators without having to depend on the actual model being updated, and this
	 * method is called by the default implementation of {@link #updateModel()} anyway (so we don't
	 * have to override that anymore).
	 */
	@Override
	protected void convertInput()
	{
		try
		{
			// Get the converted input values
			Date dateFieldInput = dateField.getConvertedInput();
			Integer hours = hoursField.getConvertedInput();
			Integer minutes = minutesField.getConvertedInput();
			AM_PM amOrPm = amOrPmChoice.getConvertedInput();

			// Default to today, if date entry was invisible
			final MutableDateTime date;
			if (dateFieldInput != null)
			{
				date = new MutableDateTime(dateFieldInput);
			}
			else
			{
				// Current date
				date = new MutableDateTime();
			}

			// always set secs to 0
			date.setSecondOfMinute(0);

			// "Calculate" the date with the different input parameters

			// The AM/PM field
			boolean use12HourFormat = use12HourFormat();
			if (use12HourFormat)
			{
				date.set(DateTimeFieldType.halfdayOfDay(), amOrPm == AM_PM.PM ? 1 : 0);
			}

			// The hours
			if ((hoursField.isVisibleInHierarchy() == false) || (hours == null))
			{
				date.setHourOfDay(0);
			}
			else
			{
				date.set(DateTimeFieldType.hourOfDay(), hours % getMaximumHours(use12HourFormat));
			}

			// The minutes
			if ((minutesField.isVisibleInHierarchy() == false) || (minutes == null))
			{
				date.setMinuteOfHour(0);
			}
			else
			{
				date.setMinuteOfHour(minutes);
			}

			// Use the client timezone to properly calculate the millisecs
			TimeZone zone = getClientTimeZone();
			if (zone != null)
			{
				date.setZoneRetainFields(DateTimeZone.forTimeZone(zone));
			}

			// The date will be in the server's timezone
			setConvertedInput(new Date(date.getMillis()));
		}
		catch (RuntimeException e)
		{
			DateTimeField.this.error(e.getMessage());
			invalid();
		}
	}

