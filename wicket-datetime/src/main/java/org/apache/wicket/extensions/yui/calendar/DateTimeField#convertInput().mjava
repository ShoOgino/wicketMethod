	/**
	 * Sets the converted input, which is an instance of {@link Date}, possibly null. It combines
	 * the inputs of the nested date, hours, minutes and am/pm fields and constructs a date from it.
	 * <p>
	 * Note that overriding this method is a better option than overriding {@link #updateModel()}
	 * like the first versions of this class did. The reason for that is that this method can be
	 * used by form validators without having to depend on the actual model being updated, and this
	 * method is called by the default implementation of {@link #updateModel()} anyway (so we don't
	 * have to override that anymore).
	 * </p>
	 * 
	 * @see org.apache.wicket.markup.html.form.FormComponent#convertInput()
	 */
	@Override
	protected void convertInput()
	{
		Object dateFieldInput = dateField.getConvertedInput();
		if (dateFieldInput != null)
		{
			MutableDateTime date = new MutableDateTime(dateFieldInput);
			Integer hours = hoursField.getConvertedInput();
			Integer minutes = minutesField.getConvertedInput();
			AM_PM amOrPm = amOrPmChoice.getConvertedInput();

			try
			{
				boolean use12HourFormat = use12HourFormat();
				if (hoursField.isVisibleInHierarchy() == false)
				{
					hours = 0;
				}
				if (hours != null)
				{
					date.set(DateTimeFieldType.hourOfDay(), hours %
						getMaximumHours(use12HourFormat));
					date.setMinuteOfHour((minutes != null) ? minutes : 0);
				}
				if (use12HourFormat)
				{
					date.set(DateTimeFieldType.halfdayOfDay(), amOrPm == AM_PM.PM ? 1 : 0);
				}

				TimeZone zone = getClientTimeZone();
				if (zone != null)
				{
					date.setMillis(getMillis(zone, TimeZone.getDefault(), date.getMillis()));
				}

				// the date will be in the server's timezone
				setConvertedInput(date.toDate());
			}
			catch (RuntimeException e)
			{
				DateTimeField.this.error(e.getMessage());
				invalid();
			}
		}
		else
		{
			setConvertedInput(null);
		}
	}

