		/**
		 * Resets the receivers childrens rows. Starting with the child at
		 * <code>childIndex</code> (and <code>modelIndex</code>) to
		 * <code>newRow</code>. This uses <code>setRowAndChildren</code> to
		 * recursively descend children, and uses <code>resetRowSelection</code>
		 * to ascend parents.
		 * 
		 * @param newRow
		 * @param childIndex
		 * @param modelIndex
		 */
		// This can be rather expensive, but is needed for the collapse
		// case this is resulting from a remove (although I could fix
		// that by having instances of TreeStateNode hold a ref to
		// the number of children). I prefer this though, making determing
		// the row of a particular node fast is very nice!
		private void resetChildrenRowsFrom(int newRow, int childIndex, int modelIndex)
		{
			int lastRow = newRow;
			int lastModelIndex = modelIndex;
			TreeStateNode node;
			int maxCounter = getChildCount();

			for (int counter = childIndex; counter < maxCounter; counter++)
			{
				node = (TreeStateNode)getChildAt(counter);
				lastRow += (node.childIndex - lastModelIndex);
				lastModelIndex = node.childIndex + 1;
				if (node.isExpanded)
				{
					lastRow = node.setRowAndChildren(lastRow);
				}
				else
				{
					node.row = lastRow++;
				}
			}
			lastRow += childCount - lastModelIndex;
			node = (TreeStateNode)getParent();
			if (node != null)
			{
				node.resetChildrenRowsFrom(lastRow, node.getIndex(this) + 1, this.childIndex + 1);
			}
			else
			{ // This is the root, reset total ROWCOUNT!
				rowCount = lastRow;
			}
		}

