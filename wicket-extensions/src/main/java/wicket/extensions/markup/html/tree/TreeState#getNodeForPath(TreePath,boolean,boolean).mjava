	/**
	 * Messages getTreeNodeForPage(path, onlyIfVisible, shouldCreate,
	 * path.length) as long as path is non-null and the length is > 0. Otherwise
	 * returns null.
	 * 
	 * @param path
	 *            the path
	 * @param onlyIfVisible
	 * @param shouldCreate
	 * @return the tree state node
	 */
	private TreeStateNode getNodeForPath(TreePath path, boolean onlyIfVisible, boolean shouldCreate)
	{
		if (path != null)
		{
			TreeStateNode node;

			node = getMapping(path);
			if (node != null)
			{
				if (onlyIfVisible && !node.isVisible())
				{
					return null;
				}
				return node;
			}
			if (onlyIfVisible)
			{
				return null;
			}

			// Check all the parent paths, until a match is found.
			ArrayListStack<TreePath> paths;

			if (tempStacks.size() == 0)
			{
				paths = new ArrayListStack<TreePath>();
			}
			else
			{
				paths = tempStacks.pop();
			}

			try
			{
				paths.push(path);
				path = path.getParentPath();
				while (path != null)
				{
					node = getMapping(path);
					if (node != null)
					{
						// Found a match, create entries for all paths in
						// paths.
						while (node != null && paths.size() > 0)
						{
							path = paths.pop();
							node = node.createChildFor(path.getLastPathComponent());
						}
						return node;
					}
					paths.push(path);
					path = path.getParentPath();
				}
			}
			finally
			{
				paths.clear();
				tempStacks.push(paths);
			}
			// If we get here it means they share a different root!
			return null;
		}
		return null;
	}

