		/**
		 * Adds newChild to this nodes children at the appropriate location. The
		 * location is determined from the childIndex of newChild.
		 * 
		 * @param newChild
		 *            the node to add
		 */
		// private void addNode(TreeStateNode newChild)
		// {
		// boolean added = false;
		// int childIndex = newChild.getChildIndex();
		//
		// for (int counter = 0, maxCounter = getChildCount(); counter <
		// maxCounter; counter++)
		// {
		// if (((TreeStateNode) getChildAt(counter)).getChildIndex() >
		// childIndex)
		// {
		// added = true;
		// insert(newChild, counter);
		// counter = maxCounter;
		// }
		// }
		// if (!added)
		// add(newChild);
		// }
		/**
		 * Removes the child at <code>modelIndex</code>.
		 * <code>isChildVisible</code> should be true if the receiver is
		 * visible and expanded.
		 * 
		 * @param modelIndex
		 * @param isChildVisible
		 */
		private void removeChildAtModelIndex(int modelIndex, boolean isChildVisible)
		{
			TreeStateNode childNode = getChildAtModelIndex(modelIndex);

			if (childNode != null)
			{
				int row = childNode.getRow();
				int index = getIndex(childNode);

				childNode.collapse(false);
				remove(index);
				adjustChildIndexs(index, -1);
				childCount--;
				if (isChildVisible)
				{
					// Adjust the rows.
					resetChildrenRowsFrom(row, index, modelIndex);
				}
			}
			else
			{
				int maxCounter = getChildCount();
				TreeStateNode aChild;

				for (int counter = 0; counter < maxCounter; counter++)
				{
					aChild = (TreeStateNode)getChildAt(counter);
					if (aChild.childIndex >= modelIndex)
					{
						if (isChildVisible)
						{
							adjustRowBy(-1, counter);
							adjustRowCountBy(-1);
						}
						// Since matched and children are always sorted by
						// index, no need to continue testing with the
						// above.
						for (; counter < maxCounter; counter++)
						{
							((TreeStateNode)getChildAt(counter)).childIndex--;
						}
						childCount--;
						return;
					}
				}
				// No children to adjust, but it was a child, so we still need
				// to adjust nodes after this one.
				if (isChildVisible)
				{
					adjustRowBy(-1, maxCounter);
					adjustRowCountBy(-1);
				}
				childCount--;
			}
		}

