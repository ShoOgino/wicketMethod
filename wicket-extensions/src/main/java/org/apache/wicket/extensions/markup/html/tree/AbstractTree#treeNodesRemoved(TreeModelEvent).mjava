	/**
	 * @see javax.swing.event.TreeModelListener#treeNodesRemoved(javax.swing.event.TreeModelEvent)
	 */
	@Override
	public final void treeNodesRemoved(TreeModelEvent removalEvent)
	{
		if (dirtyAll)
		{
			return;
		}

		// get the parent node of deleted nodes
		Object parentNode = removalEvent.getTreePath().getLastPathComponent();
		TreeItem parentItem = nodeToItemMap.get(parentNode);

		// unselect all removed items
		List<Object> selection = new ArrayList<Object>(getTreeState().getSelectedNodes());
		List<Object> removed = Arrays.asList(removalEvent.getChildren());
		for (Object selectedNode : selection)
		{
			Object cursor = selectedNode;
			while (cursor != null)
			{
				if (removed.contains(cursor))
				{
					getTreeState().selectNode(selectedNode, false);
				}
				if (cursor instanceof TreeNode)
				{
					cursor = ((TreeNode)cursor).getParent();
				}
				else
				{
					cursor = null;
				}
			}
		}

		if (parentItem != null && isNodeVisible(parentNode))
		{
			if (isNodeExpanded(parentNode))
			{
				// deleted nodes were visible; we need to delete their TreeItems
				for (Object deletedNode : removalEvent.getChildren())
				{
					TreeItem itemToDelete = nodeToItemMap.get(deletedNode);
					if (itemToDelete != null)
					{
						markTheLastButOneChildDirty(parentItem, itemToDelete);

						// remove all the deleted item's children
						visitItemChildren(itemToDelete, new IItemCallback()
						{
							@Override
							public void visitItem(TreeItem item)
							{
								removeItem(item);
							}
						});

						parentItem.getChildren().remove(itemToDelete);
						removeItem(itemToDelete);
					}
				}
			}

			if (!parentItem.hasChildTreeItems())
			{
				// rebuild parent's icon to show it no longer has children
				invalidateNode(parentNode, true);
			}
		}
	}

