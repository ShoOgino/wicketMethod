	/**
	 * Gets component path relative to the parent container with associated
	 * markup.
	 * 
	 * @param component
	 * @param parentWithAssociatedMarkup
	 *            A parent container of 'component', which has associated markup
	 *            that contains the markup fragment
	 * @return the relative path
	 */
	protected String getComponentRelativePath(final Component component,
			final MarkupContainer parentWithAssociatedMarkup)
	{
		MarkupContainer parent = component.getParent();
		if ((parent == null) || (parent == parentWithAssociatedMarkup))
		{
			return component.getId();
		}

		final StringBuffer buffer = new StringBuffer(32);
		for (; (parent != parentWithAssociatedMarkup) && (parent != null); parent = parent
				.getParent())
		{
			if (buffer.length() > 0)
			{
				buffer.insert(0, Component.PATH_SEPARATOR);
			}
			buffer.insert(0, parent.getId());
		}

		buffer.append(Component.PATH_SEPARATOR);
		buffer.append(component.getId());

		// TODO Post 1.2: A component path e.g. "panel:label" does not match
		// 1:1 with the markup in case of ListView, where the path contains
		// a number for each list item. E.g. list:0:label. What we currently
		// do is simply remove the number from the path and hope that no
		// user uses an integer for a component id. This is a hack only. A
		// much better solution would delegate to the various components
		// recursivly to search within there realm only for the components
		// markup. ListItems could then simply do nothing and delegate to
		// their parents.

		// s/:\d+//g
		final Matcher matcher = LIST_VIEW_NUMBER.matcher(buffer);
		return matcher.replaceAll("");
	}

