	/**
	 * 
	 * @see wicket.markup.markupFinder.IMarkupFinder#find(wicket.Component,
	 *      wicket.markup.MarkupStream, wicket.MarkupContainer)
	 */
	public <T> MarkupStream find(final Component<T> component, MarkupStream markupStream,
			final MarkupContainer parentWithAssociatedMarkup)
	{
		// In case the component has already been rendered, this is a
		// performance short cut. But actually this was necessary because
		// transparent containers and components which implement
		// IComponentResolver destroy the 1:1 match between component path
		// and markup path.
		if (component.getMarkupIndex() != -1)
		{
			// Might be that the markup has been reloaded and that the
			// position has changed. Make sure the component is still
			// available
			try
			{
				markupStream.setCurrentIndex(component.getMarkupIndex());
				MarkupElement elem = markupStream.get();
				if (elem instanceof ComponentTag)
				{
					ComponentTag tag = (ComponentTag)elem;
					if (tag.getId().equals(component.getId()))
					{
						// Ok, found it
						return markupStream;
					}
				}
			}
			catch (IndexOutOfBoundsException ex)
			{
				// fall through. Don't do anything
			}
		}

		// Make sure the markup stream is positioned at the correct element
		String relativePath = getComponentRelativePath(component, parentWithAssociatedMarkup);

		// If the component is defined in the markup
		int index = positionAt(markupStream, relativePath);
		if (index != -1)
		{
			return markupStream;
		}

		return null;
	}

