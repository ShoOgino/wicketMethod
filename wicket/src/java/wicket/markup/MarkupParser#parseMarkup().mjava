    /**
     * Scans the given markup string and extracts balancing tags.
     * @return An immutable list of immutable MarkupElement elements
     * @throws ParseException Thrown if markup is malformed or tags don't balance
     */
    private List parseMarkup() throws ParseException
    {
        final List autoAddList = new ArrayList();
        
        this.markupFilterChain = newFilterChain(autoAddList);
        initFilterChain();
        
        // List to return
        final List list = new ArrayList();

        try
        {
	        // Loop through tags
	        for (ComponentTag tag; null != (tag = (ComponentTag)markupFilterChain.nextTag());)
	        {
	            boolean add = (tag.getId() != null);
	            if (!add && tag.getXmlTag().isClose())
	            {
	                add = ((tag.getOpenTag() != null) && (tag.getOpenTag().getId() != null));
	            }
	            
	            // Determine wicket namespace: <html xmlns:wicket="http://wicket.sourceforge.net">
	            RawMarkup replaceTag = null;
				if (tag.isOpen() && "html".equals(tag.getName().toLowerCase()))
				{
					// if add already true, do not make it false
				    add |= determineWicketNamespace(tag);
				    
				    // If add and tag has no wicket:id, than
				    if ((add == true) && (tag.getId() == null))
				    {
				    	// Replace the current tag
				    	replaceTag = new RawMarkup(tag.toString());
				    }
				}
	
	            // Add tag to list?
	            if (add || (autoAddList.size() > 0))
	            {
	                final CharSequence text =
	                    	xmlParser.getInputFromPositionMarker(tag.getPos());
	
	                // Add text from last position to tag position
	                if (text.length() > 0)
	                {
	                    String rawMarkup = text.toString();
	
	                    if (stripComments)
	                    {
	                        rawMarkup = rawMarkup.replaceAll("<!--(.|\n|\r)*?-->", "");
	                    }
	
	                    if (compressWhitespace)
	                    {
	                        rawMarkup = rawMarkup.replaceAll("[ \\t]+", " ");
	                        rawMarkup = rawMarkup.replaceAll("( ?[\\r\\n] ?)+", "\n");
	                    }
	
	                    list.add(new RawMarkup(rawMarkup));
	                }
	
	                if ((add == false) && (autoAddList.size() > 0))
	                {
	                    xmlParser.setPositionMarker(tag.getPos());
	                }
	
	                list.addAll(autoAddList);
	                autoAddList.clear();
	            }
	            
	            if (add)
	            {
	                // Add to list unless preview component tag remover flagged as removed
	                if (!WicketRemoveTagHandler.IGNORE.equals(tag.getId()))
	                {
	                	if (replaceTag != null)
	                	{
	                		list.add(replaceTag);
	                	}
	                	else
	                	{
	                		list.add(tag);
	                	}
	                }
	                
	                xmlParser.setPositionMarker();
	            }
	        }
        }
        catch (ParseException ex)
        {
            // Add tail?
            final CharSequence text = xmlParser.getInputFromPositionMarker(-1);
            if (text.length() > 0)
            {
                list.add(new RawMarkup(text));
            }
            
        	Markup markup = new Markup(this.resource, list, getXmlDeclaration(), getEncoding(), 
                    this.wicketNamespace);
        	
        	MarkupStream markupStream = new MarkupStream(markup); 
        	markupStream.setCurrentIndex(list.size() - 1);
        	throw new MarkupException(markupStream, ex.getMessage());
        }
        
        // Add tail?
        final CharSequence text = xmlParser.getInputFromPositionMarker(-1);
        if (text.length() > 0)
        {
            list.add(new RawMarkup(text));
        }
        
        // Make all tags immutable. Note: We can not make tag immutable 
        // just prior to adding to the list, because <wicket:param> 
        // needs to modify its preceding tag (add the attributes). And 
        // because WicketParamTagHandler and ComponentTag are not in the 
        // same package, WicketParamTagHandler is not able to modify the
        // default protected variables of ComponentTag, either.
        for (int i=0; i < list.size(); i++)
        {
            MarkupElement elem = (MarkupElement) list.get(i);
            if (elem instanceof ComponentTag)
            {
                ((ComponentTag)elem).makeImmutable();
            }
        }
        
        // Return immutable list of all MarkupElements
        return Collections.unmodifiableList(list);
    }

