    /**
     * Scans the given markup string and extracts balancing tags.
     * @return An immutable list of immutable MarkupElement elements
     * @throws ParseException Thrown if markup is malformed or tags don't balance
     */
    private List parseMarkup() throws ParseException
    {
        this.markupFilterChain = newFilterChain();
        initFilterChain();
        
        // List to return
        final List list = new ArrayList();

        // If remaining tags after <wicket:extend/> shall be ignored
        // TODO remove <wicket:extend> specific code from MarkupParser
        int stripRemainingElements = -1;

        // Loop through tags
        for (ComponentTag tag; null != (tag = (ComponentTag)markupFilterChain.nextTag());)
        {
            boolean add = (tag.getId() != null);
            if (!add && tag.getXmlTag().isClose())
            {
                add = ((tag.getOpenTag() != null) && (tag.getOpenTag().getId() != null));
            }

            // Add tag to list?
            if (add)
            {
                final CharSequence text =
                    	xmlParser.getInputFromPositionMarker(tag.getPos());

                // Add text from last position to tag position
                if (text.length() > 0)
                {
                    String rawMarkup = text.toString();

                    if (stripComments)
                    {
                        rawMarkup = rawMarkup.replaceAll("<!--(.|\n|\r)*?-->", "");
                    }

                    if (compressWhitespace)
                    {
                        rawMarkup = rawMarkup.replaceAll("[ \\t]+", " ");
                        rawMarkup = rawMarkup.replaceAll("( ?[\\r\\n] ?)+", "\n");
                    }

                    list.add(new RawMarkup(rawMarkup));
                }

                // Strip raw markup preceding <wicket:extend> and following </wicket:extend>
                // Make sure no wicket components get removed
                if (tag instanceof WicketTag)
                {
                    final WicketTag wtag = (WicketTag) tag;
                    if (wtag.isExtendTag())
                    {
                        if (wtag.isOpen())
                        {
                            // TODO check if only RawMarkup
                            list.clear();
                        }
                        else if (wtag.isClose())
                        {
                            if (stripRemainingElements != -1)
                            {
                                throw new MarkupException("Have already seen a <wicket:extend> tag");
                            }
                            
                            stripRemainingElements = list.size() + 1;
                        }
                        else
                        {
                            throw new MarkupException("Unmatched open close tags for <wicket:extend>");
                        }
                    }
                }

                // Add to list unless preview component tag remover flagged as removed
                if (!WicketRemoveTagHandler.IGNORE.equals(tag.getId()))
                {
	                list.add(tag);
                }

                if (!(tag instanceof DynamicWicketTag))
                {
	                // Position is after tag
	                xmlParser.setPositionMarker();
                }
            }
        }

        // Add tail?
        final CharSequence text = xmlParser.getInputFromPositionMarker(-1);
        if (text.length() > 0)
        {
            list.add(new RawMarkup(text));
        }
        
        // Remove raw markup following </wicket:extend>
        if (stripRemainingElements != -1)
        {
            for (int i = list.size() - 1; i >= stripRemainingElements; i--)
            {
                // TODO check if only RawMarkup
                list.remove(i);
            }
        }

        // Make all tags immutable. Note: We can not make tag immutable 
        // just prior to adding to the list, because <wicket:param> 
        // needs to modify its preceding tag (add the attributes). And 
        // because WicketParamTagHandler and ComponentTag are not in the 
        // same package, WicketParamTagHandler is not able to modify the
        // default protected variables of ComponentTag, either.
        for (int i=0; i < list.size(); i++)
        {
            MarkupElement elem = (MarkupElement) list.get(i);
            if (elem instanceof ComponentTag)
            {
                ((ComponentTag)elem).makeImmutable();
            }
        }
        
        // Return immutable list of all MarkupElements
        return Collections.unmodifiableList(list);
    }

