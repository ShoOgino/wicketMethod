	/**
	 * Scans the given markup and extracts balancing tags.
	 * 
	 */
	private void parseMarkup()
	{
		// Handlers may add MarkupElements which were not found in the markup
		// file.
		final List<ComponentTag> autoAddList = new ArrayList<ComponentTag>();

		// Initialize the markup filter chain
		this.markupFilterChain = newFilterChain(autoAddList);
		
		// Allow subclasses to extend the filter chain
		initFilterChain();

		// Get relevant settings from the Application
		boolean stripComments = this.markupSettings.getStripComments();
		boolean compressWhitespace = this.markupSettings.getCompressWhitespace();

		try
		{
			// Loop through tags
			for (ComponentTag tag; null != (tag = (ComponentTag)markupFilterChain.nextTag());)
			{
				boolean add = (tag.getId() != null);
				if (!add && tag.getXmlTag().isClose())
				{
					add = ((tag.getOpenTag() != null) && (tag.getOpenTag().getId() != null));
				}

				// Determine wicket namespace: <html
				// xmlns:wicket="http://wicket.sourceforge.net">
				RawMarkup replaceTag = null;
				if (tag.isOpen() && "html".equals(tag.getName().toLowerCase()))
				{
					// if add already true, do not make it false
					add |= determineWicketNamespace(tag);

					// If add and tag has no wicket:id, than
					if ((add == true) && (tag.getId() == null))
					{
						// Replace the current tag
						replaceTag = new RawMarkup(tag.toCharSequence());
					}
				}

				// Add tag to list?
				if (add || (autoAddList.size() > 0) || tag.isModified())
				{
					final CharSequence text = xmlParser.getInputFromPositionMarker(tag.getPos());

					// Add text from last position to tag position
					if (text.length() > 0)
					{
						String rawMarkup = text.toString();

						if (stripComments)
						{
							rawMarkup = removeComment(rawMarkup);
						}

						if (compressWhitespace)
						{
							rawMarkup = rawMarkup.replaceAll("[ \\t]+", " ");
							rawMarkup = rawMarkup.replaceAll("( ?[\\r\\n] ?)+", "\n");
						}

						this.markup.addMarkupElement(new RawMarkup(rawMarkup));
					}

					if ((add == false) && (autoAddList.size() > 0))
					{
						xmlParser.setPositionMarker(tag.getPos());
					}

					for (int i = 0; i < autoAddList.size(); i++)
					{
						this.markup.addMarkupElement(autoAddList.get(i));
					}
					autoAddList.clear();
				}

				if (add)
				{
					// Add to list unless preview component tag remover flagged
					// as removed
					if (!WicketRemoveTagHandler.IGNORE.equals(tag.getId()))
					{
						if (replaceTag != null)
						{
							this.markup.addMarkupElement(replaceTag);
						}
						else
						{
							this.markup.addMarkupElement(tag);
						}
					}

					xmlParser.setPositionMarker();
				}
				else if (tag.isModified())
				{
					this.markup.addMarkupElement(new RawMarkup(tag.toCharSequence()));
					xmlParser.setPositionMarker();
				}
			}
		}
		catch (ParseException ex)
		{
			// Add remaining input string
			final CharSequence text = xmlParser.getInputFromPositionMarker(-1);
			if (text.length() > 0)
			{
				this.markup.addMarkupElement(new RawMarkup(text));
			}

			this.markup.setEncoding(xmlParser.getEncoding());
			this.markup.setXmlDeclaration(xmlParser.getXmlDeclaration());

			MarkupStream markupStream = new MarkupStream(markup);
			markupStream.setCurrentIndex(this.markup.size() - 1);
			throw new MarkupException(markupStream, ex.getMessage(), ex);
		}

		// Add tail?
		final CharSequence text = xmlParser.getInputFromPositionMarker(-1);
		if (text.length() > 0)
		{
			this.markup.addMarkupElement(new RawMarkup(text));
		}

		// Make all tags immutable and the list of elements unmodifable
		this.markup.makeImmutable();
	}

