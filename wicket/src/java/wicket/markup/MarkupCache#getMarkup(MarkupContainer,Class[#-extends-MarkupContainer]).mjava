	/**
	 * Gets any (immutable) markup resource for the container or any of its
	 * parent classes (markup inheritance)
	 * 
	 * @param container
	 *            The original requesting markup container
	 * @param clazz
	 *            The class to get the associated markup for. If null, the
	 *            container's class is used, but it can be a parent class of the
	 *            container as well (markup inheritance)
	 * @return Markup resource
	 */
	private final Markup getMarkup(final MarkupContainer container, final Class<? extends MarkupContainer> clazz)
	{
		Class<? extends MarkupContainer> containerClass = clazz;
		if (clazz == null)
		{
			containerClass = container.getClass();
		}
		else
		{
			if (!clazz.isAssignableFrom(container.getClass()))
			{
				throw new WicketRuntimeException("Parameter clazz must be instance of container");
			}
		}

		// Look up markup tag list by class, locale, style and markup type
		final CharSequence key = markupKey(container, clazz);
		Markup markup = markupCache.get(key);

		// If no markup in the cache
		if (markup == null)
		{
			synchronized (markupCache)
			{
				markup = markupCache.get(key);

				// If no markup is in the cache
				if (markup == null)
				{
					// Ask the container to locate its associated markup
					final IResourceStream resourceStream = container
							.newMarkupResourceStream(containerClass);

					// Found markup?
					if (resourceStream != null)
					{
						final MarkupResourceStream markupResource;
						if (resourceStream instanceof MarkupResourceStream)
						{
							markupResource = (MarkupResourceStream)resourceStream;
						}
						else
						{
							markupResource = new MarkupResourceStream(resourceStream,
									new ContainerInfo(container), containerClass);
						}
						
						// load the markup and watch for changes
						markup = loadMarkupAndWatchForChanges(container, key, markupResource);
					}
					else
					{
						// flag markup as non-existent (as opposed to null,
						// which might mean that it's simply not loaded into
						// the cache)
						markup = Markup.NO_MARKUP;

						// Save any markup list (or absence of one) for next
						// time
						markupCache.put(key, markup);
					}
				}
			}
		}
		return markup;
	}

