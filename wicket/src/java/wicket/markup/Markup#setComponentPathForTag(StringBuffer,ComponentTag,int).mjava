	/**
	 * Based on the tag and its current tag path create a cache entry and update
	 * the tag path again depending on the tag
	 * 
	 * @param tagPath
	 *            The current tag path in the markup
	 * @param tag
	 *            The current tag
	 * @param tagIndex
	 *            The index of the tag within the markup
	 * @return Updated tag path for the next ComponentTag in the markup
	 */
	private StringBuffer setComponentPathForTag(final StringBuffer tagPath, final ComponentTag tag,
			final int tagIndex)
	{
		// Only if the tag has wicket:id="xx" and open or open-close
		if ((tag.isOpen() || tag.isOpenClose()) && tag.getAttributes().containsKey(wicketId))
		{
			int size = tagPath.length();
			if (size > 0)
			{
				tagPath.append(TAG_PATH_SEPARATOR);
			}
			tagPath.append(tag.getId());

			this.componentMap.put(tagPath.toString(), new Integer(tagIndex));

			// With open-close the path does not change. It can/will not have
			// children. The same is true for HTML tags like <br> or <img>
			// which might not have close tags.
			if (tag.isOpenClose() || tag.hasNoCloseTag())
			{
				tagPath.setLength(size);
			}
		}
		else if (tag.isClose() && (tagPath != null))
		{
			// For example <wicket:message> does not have an id
			if ((tag.getOpenTag() == null)
					|| tag.getOpenTag().getAttributes().containsKey(wicketId))
			{
				// Remove the last element from the component path
				final int index = tagPath.lastIndexOf(String.valueOf(TAG_PATH_SEPARATOR));
				if (index != -1)
				{
					tagPath.setLength(index);
				}
				else
				{
					tagPath.setLength(0);
				}
			}
		}

		return tagPath;
	}

