	/**
	 * Border makes use of a &lt;wicket:body&gt; tag to indentify the position
	 * to insert within the border's body. As &lt;wicket:body&gt; is a special 
     * tag and Container is not able to handle it, we do that here.
	 * 
	 * @param markupStream
	 *            The current markup stream
	 * @param tag
	 *            The current component tag
	 * @return True, if Container was able to resolve the component name and to
	 *         render the component
	 */
	protected boolean resolveComponent(final MarkupStream markupStream, final ComponentTag tag)
	{
		// Determine if tag is a <wicket:body> tag
		final boolean isBodyTag = (tag instanceof ComponentWicketTag && markupStream.atOpenCloseTag("body"));

		// If we're being asked to resolve a component for a <wicket:body> tag
		if (!isBodyTag)
        {
            return false;
        }
        else
		{
			// Check that it's <wicket:body/> not <wicket:body>
			if (!markupStream.atOpenCloseTag())
			{
				markupStream.throwMarkupException("A <wicket:body> tag must be an open-close tag.");
			}

			// Render the body tag
			renderTag(tag);
			markupStream.next();

			// Find nearest Border at or above this container
			Border border = (Border)((this instanceof Border) ? this : findParent(Border.class));

			// If markup stream is null, that indicates we already recursed into
			// this block of log and set it to null (below). If we did that,
			// then we want to go up another level of border nesting.
			if (border.getMarkupStream() == null)
			{
				// Find Border at or above parent of this border
				final Container borderParent = border.getParent();
				border = (Border)((borderParent instanceof Border) ? borderParent : borderParent
						.findParent(Border.class));
			}

			// Get the border's markup
			final MarkupStream borderMarkup = border.findMarkupStream();

			// Set markup of border to null. This allows us to find the border's
			// parent's markup. It also indicates that we've been here in the
			// log just above.
			border.setMarkupStream(null);

			// Draw the children of the border component using its original
			// in-line markup stream (not the border's associated markup stream)
			border.renderBody(border.findMarkupStream(), border.openTag);

			// Restore border markup so it can continue rendering
			border.setMarkupStream(borderMarkup);
			return true;
		}
	}

