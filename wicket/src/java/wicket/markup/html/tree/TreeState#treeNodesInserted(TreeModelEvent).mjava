	/**
	 * <p>
	 * Invoked after nodes have been inserted into the tree.
	 * </p>
	 * <p>
	 * e.path() returns the parent of the new nodes
	 * <p>
	 * e.childIndices() returns the indices of the new nodes in ascending order.
	 * @param e the tree model event
	 */
	public void treeNodesInserted(TreeModelEvent e)
	{
		if (e != null)
		{
			int changedIndexs[];
			TreeStateNode changedParent = getNodeForPath(e.getTreePath(), false, false);
			int maxCounter;

			changedIndexs = e.getChildIndices();
			/*
			 * Only need to update the children if the node has been expanded once.
			 */
			// PENDING(scott): make sure childIndexs is sorted!
			if (changedParent != null && changedIndexs != null
					&& (maxCounter = changedIndexs.length) > 0)
			{
				boolean isVisible = (changedParent.isVisible() && changedParent.isExpanded());

				for (int counter = 0; counter < maxCounter; counter++)
				{
					changedParent.childInsertedAtModelIndex(changedIndexs[counter], isVisible);
				}
				if (isVisible && treeSelectionModel != null)
					treeSelectionModel.resetRowSelection();
				if (changedParent.isVisible())
					this.visibleNodesChanged();
			}
		}
	}

