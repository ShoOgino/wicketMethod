	/**
	 * <p>
	 * Invoked after a node (or a set of siblings) has changed in some way. The
	 * node(s) have not changed locations in the tree or altered their children
	 * arrays, but other attributes have changed and may affect presentation.
	 * Example: the name of a file has changed, but it is in the same location
	 * in the file system.
	 * </p>
	 * <p>
	 * e.path() returns the path the parent of the changed node(s).
	 * </p>
	 * <p>
	 * e.childIndices() returns the index(es) of the changed node(s).
	 * </p>
	 * 
	 * @param e
	 *			  the tree model event
	 */
	public void treeNodesChanged(TreeModelEvent e)
	{
		if (e != null)
		{
			int changedIndexs[];
			TreeStateNode changedParent = getNodeForPath(e.getTreePath(), false, false);
			int maxCounter;

			changedIndexs = e.getChildIndices();
			/*
			 * Only need to update the children if the node has been expanded
			 * once.
			 */
			// PENDING(scott): make sure childIndexs is sorted!
			if (changedParent != null)
			{
				if (changedIndexs != null && (maxCounter = changedIndexs.length) > 0)
				{
					Object parentValue = changedParent.getUserObject();

					for (int counter = 0; counter < maxCounter; counter++)
					{
						TreeStateNode child = changedParent
								.getChildAtModelIndex(changedIndexs[counter]);

						if (child != null)
						{
							child.setUserObject(treeModel.getChild(parentValue,
									changedIndexs[counter]));
						}
					}
					if (changedParent.isVisible() && changedParent.isExpanded())
					{
						visibleNodesChanged();
					}
				}
				// Null for root indicates it changed.
				else if (changedParent == root
						&& changedParent.isVisible() && changedParent.isExpanded())
				{
					visibleNodesChanged();
				}
			}
		}
	}

