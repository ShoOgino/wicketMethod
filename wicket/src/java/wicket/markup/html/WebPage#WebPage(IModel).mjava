	/**
	 * @see Page#Page(IModel)
	 */
	protected WebPage(final IModel model)
	{
		super(model);
		
		// Add a Body container if the associated markup contains a <body> tag
		// get markup stream gracefully
		MarkupStream markupStream = getApplication().getMarkupCache().getMarkupStream(this, false);
		if (markupStream != null)
		{
			// The default <body> container. It can be accessed, replaced 
			// and attribute modifiers can be attached. <body> tags without
			// wicket:id get automatically a wicket:id="body" assigned.
//			 find the body tag
			while (markupStream.hasMore())
			{
				final MarkupElement element = (MarkupElement)markupStream.next();
				if (element instanceof ComponentTag)
				{
					final ComponentTag tag = (ComponentTag)element;
					if (tag.isOpen() && "body".equals(tag.getName()) && (tag.getNamespace() == null))
					{
						// Add a default container if the tag has the default _body name
						if(BodyOnLoadHandler.BODY_ID.equals(tag.getId()))
						{
							add(new HtmlBodyContainer());
						}
						// remember the id of the tag
						bodyContainer = new BodyContainer(this,tag.getId());
						break;
					}
				}
			}
		}
		
		// TODO General: If the concept proofs valuable we could add the header 
		// container the same way instead of using a resolver. The advantages 
		// would be that the header container be available at build time already 
		// and not only at render time.
	}

