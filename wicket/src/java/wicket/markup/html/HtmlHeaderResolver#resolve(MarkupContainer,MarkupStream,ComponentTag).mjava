	/**
	 * Try to resolve the tag, then create a component, add it to the container
	 * and render it.
	 * 
	 * @see wicket.IComponentResolver#resolve(MarkupContainer, MarkupStream,
	 *      ComponentTag)
	 * 
	 * @param container
	 *            The container parsing its markup
	 * @param markupStream
	 *            The current markupStream
	 * @param tag
	 *            The current component tag while parsing the markup
	 * @return true, if componentId was handle by the resolver. False, otherwise
	 */
	public boolean resolve(final MarkupContainer container, final MarkupStream markupStream,
			final ComponentTag tag)
	{
		// Only <head> component tags have the id == "_header"
		if (tag.getId().equals(HtmlHeaderSectionHandler.HEADER_ID))
		{
			// Create a special header component which will gather additional
			// input the <head> from 'contributors'.
			final WebMarkupContainer header = new HtmlHeaderContainer(
					HtmlHeaderSectionHandler.HEADER_ID);
			container.autoAdd(header);

			// Yes, we handled the tag
			return true;
		}
		else if ((tag instanceof WicketTag) && "head".equalsIgnoreCase(tag.getName())
				&& (tag.getNamespace() != null))
		{
		    // If we found <wicket:head> without surrounding <head> on a Page,
		    // than we have to add wicket:head into a automatically generated
		    // head first.
		    if (container instanceof WebPage)
		    {
				// Create a special header component which will gather additional
				// input the <head> from 'contributors'.
				final WebMarkupContainer header = new HtmlHeaderContainer(
						HtmlHeaderSectionHandler.HEADER_ID);
				
				// It is <wicket:head>. Because they do not provide any additional
				// functionality there are merely a means of surroounding relevant
				// markup. Thus we simply create a WebMarkupContainer to handle
				// the tag.
				final WebMarkupContainer header2 = new WebMarkupContainer(
						HtmlHeaderSectionHandler.HEADER_ID);
				header2.setRenderBodyOnly(true);
				
				header.add(header2);
				
				container.autoAdd(header);
		    }
		    else
		    {
				// It is <wicket:head>. Because they do not provide any additional
				// functionality there are merely a means of surroounding relevant
				// markup. Thus we simply create a WebMarkupContainer to handle
				// the tag.
				final WebMarkupContainer header = new WebMarkupContainer(
						HtmlHeaderSectionHandler.HEADER_ID);
				header.setRenderBodyOnly(true);
	
				try
				{
					container.autoAdd(header);
				}
				catch (IllegalArgumentException ex)
				{
					throw new WicketRuntimeException("If the root exception says something like "
							+ "\"A child with id '_header' already exists\" "
							+ "then you most likely forgot to override autoAdd() "
							+ "in your bordered page component.", ex);
				}
		    }
		    
			// Yes, we handled the tag
			return true;
		}

		// We were not able to handle the tag
		return false;
	}

