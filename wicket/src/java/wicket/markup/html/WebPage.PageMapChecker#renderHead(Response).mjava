		/**
		 * @see wicket.markup.html.IHeaderContributor#renderHead(wicket.Response)
		 */
		public void renderHead(final Response response)
		{
			final RequestCycle cycle = getRequestCycle();
			final IRequestTarget target = cycle.getRequestTarget();
			
			// if(!isStateless()) TODO this shouldn't be done for stateless pages.
			// This will make all pages statefull. But how do we know that if
			// it is stateless because that is only know after render.
			// Should we use a Response Filter??
			int initialAccessStackSize = 0;
			if (getApplication().getRequestCycleSettings().getRenderStrategy() == IRequestCycleSettings.REDIRECT_TO_RENDER
					&& target instanceof RedirectPageRequestTarget)
			{
				initialAccessStackSize = 1;
			}
			
			// Javascript: for the most part it is getting the same functionality
			// for multiple browsers. What the end result is, is that a call back
			// to the server is made at the moment it detects that there is  
			// no history. because that could mean that a page is opened in 
			// a new tab/window without that page being in its own pagemap, 
			// that redirect will put that page in its own pagemap.
			final ArrayListStack accessStack = getPageMap().getAccessStack();
			if (accessStack.size() > initialAccessStackSize)
			{
				response.write("<script language=\"JavaScript\">if((history.length == 0 && document.all) || (history.length == 1 && !document.all)){ if (!document.all) window.location.hash='some-random-hash!'; document.location.href = '");
				if (target instanceof IBookmarkablePageRequestTarget)
				{
					IBookmarkablePageRequestTarget current = (IBookmarkablePageRequestTarget)target; 
					BookmarkablePageRequestTarget redirect = new BookmarkablePageRequestTarget(getSession().createAutoPageMapName(),
							current.getPageClass(), current.getPageParameters());
					response.write(cycle.urlFor(redirect));
				}
				else
				{
					response.write(urlFor(INewBrowserWindowListener.INTERFACE));
				}
				response.write("'}</script>");
			}
		}

