	/**
	 * Gets any (immutable) markup resource for the container or any of its
	 * parent classes (markup inheritance)
	 * 
	 * @param container
	 *            The original requesting markup container
	 * @param containerInfo
	 *            The container the markup should be associated with
	 * @param clazz
	 *            The class to get the associated markup for. If null, the
	 *            container's class is used, but it can be a parent class of the
	 *            container as well (markup inheritance)
	 * @return Markup resource
	 */
	private final Markup getMarkup(final MarkupContainer container,
			final ContainerInfo containerInfo, final Class clazz)
	{
		Class containerClass = clazz;
		if (clazz == null)
		{
			containerClass = containerInfo.getContainerClass();
		}
		else
		{
			if (!clazz.isAssignableFrom(containerInfo.getContainerClass()))
			{
				throw new WicketRuntimeException("Parameter clazz must be instance of container");
			}
		}

		// Look up markup tag list by class, locale, style and markup type
		final AppendingStringBuffer key = markupKey(containerInfo, clazz);
		Markup markup = (Markup)markupCache.get(key);

		// If no markup in the cache
		if (markup == null)
		{
			synchronized (markupCache)
			{
				markup = (Markup)markupCache.get(key);

				// If no markup in the cache
				if (markup == null)
				{
					// Locate markup resource, searching up class hierarchy
					MarkupResourceStream markupResource = null;
					while ((markupResource == null) && (containerClass != MarkupContainer.class))
					{
						// Look for markup resource for containerClass
						markupResource = newMarkupResourceStream(container, containerClass,
								containerInfo);

						containerClass = containerClass.getSuperclass();
					}

					// Found markup?
					if (markupResource != null)
					{
						// load the markup and watch for changes
						markup = loadMarkupAndWatchForChanges(container, key, markupResource);
					}
					else
					{
						// flag markup as non-existent (as opposed to null,
						// which
						// might mean that it's simply not loaded into the
						// cache)
						markup = Markup.NO_MARKUP;

						// Save any markup list (or absence of one) for next
						// time
						markupCache.put(key, markup);
					}
				}
			}
		}
		return markup;
	}

