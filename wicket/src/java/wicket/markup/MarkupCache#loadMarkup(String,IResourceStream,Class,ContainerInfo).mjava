	/**
	 * Loads markup from a resource stream.
	 * 
	 * @param key
	 *            Key under which markup should be cached
	 * @param markupResourceStream
	 *            The markup resource stream to load
	 * @param containerClass
	 *            The Class the associated stream is directly associated
	 * @param containerInfo
	 *            The container requesting the markup
	 * @return The markup
	 */
	private final Markup loadMarkup(final String key, final IResourceStream markupResourceStream,
			final Class containerClass, final ContainerInfo containerInfo)
	{
		try
		{
		    // read and parse the markup
			Markup markup = application.newMarkupParser(containerInfo).readAndParse(
					markupResourceStream);
			markup.setContainerClass(containerClass);

			// Check for markup inheritance. If it contains <wicket:extend>
			// the two markups get merged.
			markup = checkForMarkupInheritance(key, markup, containerClass, containerInfo);

			// add the markup to the cache
			synchronized (markupCache)
			{
				markupCache.put(key, markup);
			}

			// trigger all listeners registered on the markup just loaded
			afterLoadListeners.notifyListeners(markupResourceStream);

			return markup;
		}
		catch (ParseException e)
		{
			log.error("Unable to parse markup from " + markupResourceStream, e);
		}
		catch (ResourceStreamNotFoundException e)
		{
			log.error("Unable to find markup from " + markupResourceStream, e);
		}
		catch (IOException e)
		{
			log.error("Unable to read markup from " + markupResourceStream, e);
		}

		synchronized (markupCache)
		{
			markupCache.remove(key);
			afterLoadListeners.remove(markupResourceStream);
		}

		return Markup.NO_MARKUP;
	}

