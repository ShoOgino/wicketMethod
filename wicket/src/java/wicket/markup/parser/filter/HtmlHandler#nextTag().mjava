    /**
     * Get the next MarkupElement from the parent MarkupFilter and handle it
     * if the specific filter criteria are met. Depending on the filter, it 
     * may return the MarkupElement unchanged, modified or it remove by
     * asking the parent handler for the next tag.
     * 
     * @see wicket.util.xml.IMarkupFilter#nextTag()
     * @return Return the next eligible MarkupElement
     */
    public MarkupElement nextTag() throws ParseException
    {
        // Get the next tag. If null, no more tags are available
        final ComponentTag tag = (ComponentTag) parent.nextTag();
        if (tag == null)
        {
            // No more tags from the markup.
            // If there's still a non-simple tag left, it's an error
            while (stack.size() > 0)
            {
                final XmlTag top = (XmlTag) stack.peek();

                if (!requiresCloseTag(top.getName()))
                {
                    stack.pop();
                }
                else
                {
                    throw new ParseException("Tag " + top + " at " + top.getPos()
                            + " did not have a close tag", top.getPos());
                }
            }
          
            return tag;
        }

        if (log.isDebugEnabled())
        {
            log.debug("tag: " + tag.toUserDebugString() + ", stack: " + stack);
        }

        // Check tag type
        if (tag.isOpen())
        {
            // Push onto stack
            stack.push(tag);
        }
        else if (tag.isClose())
        {
            // Check that there is something on the stack
            if (stack.size() > 0)
            {
                // Pop the top tag off the stack
                ComponentTag top = (ComponentTag) stack.pop();

                // If the name of the current close tag does not match the
                // tag on the stack
                // then we may have a mismatched close tag
                boolean mismatch = !top.getName().equalsIgnoreCase(tag.getName());

                if (mismatch)
                {
                    // Pop any simple tags off the top of the stack
                    while (mismatch && !requiresCloseTag(top.getName()))
                    {
                        // Pop simple tag
                        top = (ComponentTag) stack.pop();

                        // Does new top of stack mismatch too?
                        mismatch = !top.getName().equalsIgnoreCase(tag.getName());
                    }

                    // If adjusting for simple tags did not fix the problem,
                    // it must be a real mismatch.
                    if (mismatch)
                    {
                        throw new MarkupException("Tag "
                                + top.toUserDebugString() + " has a mismatched close tag at "
                                + tag.toUserDebugString());
                    }
                }

                // Tag matches, so add pointer to matching tag
                tag.setOpenTag(top);
            }
            else
            {
                throw new MarkupException("Tag "
                        + tag.toUserDebugString() 
                        + " does not have a matching open tag");
            }
        }
        else if (tag.isOpenClose())
        {
            // Tag closes itself
            tag.setOpenTag(tag);
        }
        
        return tag;
    }

