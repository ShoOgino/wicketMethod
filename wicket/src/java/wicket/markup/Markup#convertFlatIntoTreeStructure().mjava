	/**
	 * MarkupParser until now creates a flat list of RawMarkup and ComponentTag
	 * elements. However, what we want is a tree like structure with one
	 * fragment per Component.
	 */
	private void convertFlatIntoTreeStructure()
	{
		MarkupFragment rootFragment = new MarkupFragment(this);

		// Remember the path associated with a ComponentTag to properly walk up
		// and down the hierarchy of wicket markup tags
		Stack<String> stack = new Stack<String>();
		String basePath = null;

		Stack<MarkupFragment> fragmentStack = new Stack<MarkupFragment>();
		MarkupFragment current = rootFragment;

		// For all markup element in the external markup file
		for (MarkupElement elem : this.markupFragments)
		{
			// If RawMarkup simply add the element to the current fragment
			if (elem instanceof RawMarkup)
			{
				current.addMarkupElement(elem);
			}
			else
			// if (elem instanceof ComponentTag)
			{
				// Construct the markup path for the tag
				final ComponentTag tag = (ComponentTag)elem;
				final String path = (basePath == null ? tag.getId() : basePath
						+ Component.PATH_SEPARATOR + tag.getId());

				// Depending on tag type (open, close, open-close) ...
				if (tag.isOpen())
				{
					// Open tags with no close tags (HTML) are treated like
					// open-close.
					if (tag.hasNoCloseTag())
					{
						current.addMarkupElement(new MarkupFragment(this, tag));
					}
					else
					{
						// If open tag and auto component (BODY, HEAD, etc.)
						// than the markup path gets not updated as the markup
						// for BODY e.g. does not have a wicket:id.

						stack.push(basePath);
						fragmentStack.push(current);

						MarkupFragment newFragment = new MarkupFragment(this, tag);
						current.addMarkupElement(newFragment);
						current = newFragment;

						if (!tag.getId().startsWith(Component.AUTO_COMPONENT_PREFIX))
						{
							basePath = path;
						}
					}
				}
				else if (tag.isOpenClose())
				{
					MarkupFragment newFragment = new MarkupFragment(this, tag);
					current.addMarkupElement(newFragment);
				}
				else
				// if (tag.isClose()
				{
					current.addMarkupElement(tag);
					current = fragmentStack.pop();
					basePath = stack.pop();
				}
			}
		}

		if ((rootFragment.size() == 1) && (rootFragment.get(0) instanceof MarkupFragment))
		{
			rootFragment = (MarkupFragment)rootFragment.get(0);
		}

		this.markupFragments = rootFragment;
	}

