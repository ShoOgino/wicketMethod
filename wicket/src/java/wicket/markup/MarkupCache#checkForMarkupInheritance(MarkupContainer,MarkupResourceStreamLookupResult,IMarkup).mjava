	/**
	 * The markup has just been loaded and now we check if markup inheritance
	 * applies, which is if <wicket:extend> is found in the markup. If yes, than
	 * load the base markups and merge the markup elements to create an updated
	 * (merged) list of markup elements.
	 * 
	 * @param container
	 *            The original requesting markup container
	 * @param lookupResult
	 *            Key under which markup should be cached
	 * @param markup
	 *            The markup to checked for inheritance
	 * @return A markup object with the the base markup elements resolved.
	 */
	@SuppressWarnings("unchecked")
	private IMarkup checkForMarkupInheritance(final MarkupContainer container,
			final MarkupResourceStreamLookupResult lookupResult, final IMarkup markup)
	{
		// Check if markup contains <wicket:extend> which tells us that
		// we need to read the inherited markup as well.
		int extendIndex = requiresBaseMarkup(markup);
		if (extendIndex == -1)
		{
			// return a MarkupStream for the markup
			return markup;
		}

		Class<? extends MarkupContainer> markupClass = markup.getResource().getMarkupClass();
		// get the base markup
		final IMarkup baseMarkup = getMarkup(container,
				(Class<? extends MarkupContainer>)markupClass.getSuperclass());

		if (baseMarkup == IMarkup.NO_MARKUP)
		{
			throw new MarkupNotFoundException(
					"Parent markup of inherited markup not found. Component class: "
							+ markup.getResource().getContainerInfo().getContainerClass().getName()
							+ " Enable debug messages for wicket.util.resource.Resource to get a list of all filenames tried.");
		}

		// register an after-load listener for base markup. The listener
		// implementation will remove the derived markup which must be merged
		// with the base markup
		afterLoadListeners.add(baseMarkup.getResource(), new IChangeListener()
		{
			public void onChange()
			{
				if (log.isDebugEnabled())
				{
					log.debug("Remove derived markup from cache: " + markup.getResource());
				}
				removeMarkup(lookupResult);
			}

			/**
			 * Make sure there is only one listener per derived markup
			 * 
			 * @see java.lang.Object#equals(java.lang.Object)
			 */
			@Override
			public boolean equals(Object obj)
			{
				return true;
			}

			/**
			 * Make sure there is only one listener per derived markup
			 * 
			 * @see java.lang.Object#hashCode()
			 */
			@Override
			public int hashCode()
			{
				return lookupResult.getCacheKey().hashCode();
			}
		});

		// Merge base and derived markup
		IMarkup mergedMarkup = new MergedMarkup(markup, baseMarkup, extendIndex);
		return mergedMarkup;
	}

