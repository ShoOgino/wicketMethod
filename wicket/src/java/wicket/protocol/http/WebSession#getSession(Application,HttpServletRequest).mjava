	/**
	 * Gets session from request, creating a new one if it doesn't already exist
	 * 
	 * @param application
	 *            The application object
	 * @param request
	 *            The http request object
	 * @return The session object
	 */
	static WebSession getSession(final Application application, final HttpServletRequest request)
	{
		// Get session, creating if it doesn't exist
		final javax.servlet.http.HttpSession httpServletSession = request.getSession(true);

		// The request session object is unique per web application, but wicket
		// requires it to be unique per servlet. That is, there must be a 1..n 
		// relationship between HTTP sessions (JSESSIONID) and Wicket applications.
		final String sessionAttributeName = "session" + request.getServletPath();

		// Get Session abstraction from httpSession attribute
		WebSession webSession = (WebSession)httpServletSession.getAttribute(sessionAttributeName);

		if (webSession == null)
		{
			// Create session using session factory
			final Session session = application.getSessionFactory().newSession();
			if (session instanceof WebSession)
			{
				webSession = (WebSession)session;
			}
			else
			{
				throw new WicketRuntimeException(
						"Session created by a WebApplication session factory must be a subclass of WebSession");
			}

			// Set the client Locale for this session
			webSession.setLocale(request.getLocale());
		}
		
		// Attach / reattach http servlet session
		webSession.httpSession = httpServletSession;

		// In a clustered environment the session is not replicated
		// if it is not dirty. If we just read the http session object
		// and manipulate that then the http servlet session never gets
		// flagged as being dirty. We therefore need to force a
		// change on the http servlet session to ensure clustering
		// replication occurs.
		httpServletSession.setAttribute(sessionAttributeName, webSession);

		// Set the current session to the session we just retrieved
		Session.set(webSession);

		return webSession;
	}

