	/**
	 * handle the current step in the request processing.
	 * 
	 * @param processor
	 *            the cycle processor that can be used
	 */
	private final void step(IRequestCycleProcessor processor)
	{
		try
		{
			switch (currentStep)
			{
				case PREPARE_REQUEST : {
					// prepare the request
					prepare();
					break;
				}
				case DECODE_PARAMETERS : {
					// get the request parameters object using the request
					// encoder of the processor
					requestParameters = getRequestParameters(processor);
					break;
				}
				case RESOLVE_TARGET : {
					// resolve the target of the request using the request
					// parameters
					final IRequestTarget target = processor.resolve(this, requestParameters);

					// has to result in a request target
					if (target == null)
					{
						throw new WicketRuntimeException(
								"the processor did not resolve to any request target");
					}
					requestTargets.push(target);
					break;
				}
				case PROCESS_EVENTS : {
					// determine what kind of synchronization is to be used, and
					// handle any events with that and generate a response in
					// that same block
					// NOTE: because of synchronization, we need to take the
					// steps PROCESS_EVENS and RESPOND together
					processEventsAndRespond(processor);
					break;
				}
				case RESPOND : {
					// generate a response
					// NOTE: We have to do sync here because the
					// processEventsAndRespond
					// step will be unrolled by a RestartXX Exception.
					// And if this is not the case then still it is not a
					// problem
					// to have 2 locks on the same session this will not cause a
					// deadlock.
					// So only if the request targets are different and the
					// getLock()
					// doesn't return 2 times the same object a deadlock could
					// maybe occur.
					// But we use the session as the lock at all times maybe use
					// a variable
					// inside RequestCycle to know that a lock is still in
					// place?
					respond(processor);
					break;
				}
				default : {
					// nothing
				}
			}
		}
		catch (AbstractRestartResponseException e)
		{
			throw e;
		}
		catch (RuntimeException e)
		{
			// set step manually to handle exception
			currentStep = HANDLE_EXCEPTION;

			// probably our last chance the exception can be logged
			log.error(e.getMessage(), e);

			// try to play nicely and let the request processor handle the
			// exception response. If that doesn't work, any runtime exception
			// will automatically be bubbled up
			if (processor != null)
			{
				processor.respond(e, this);
			}
		}
	}

