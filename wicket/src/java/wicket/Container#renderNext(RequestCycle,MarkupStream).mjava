	/**
	 * Renders the next element of markup in the given markup stream.
	 * 
	 * @param cycle
	 *           The wicket.response to write to
	 * @param markupStream
	 *           The markup stream
	 */
	private void renderNext(final RequestCycle cycle, final MarkupStream markupStream)
	{
		// Get the current markup element
		final MarkupElement element = markupStream.get();

		// Is it a component?
		if (element instanceof ComponentTag && (!markupStream.atCloseTag()))
		{
			// Get element as tag
			final ComponentTag tag = (ComponentTag) element;

			// Get component name
			final String componentName = tag.getComponentName();

			// Get the component for the component name from the given container
			Component component = get(componentName);

			// Check for automatic links
			if ((component == null) && tag.isAutomaticLink())
			{
				// Add automaticLink external page link
				component = tag.createAutomaticLink(getPage(), markupStream);
				add(component);
				if (log.isDebugEnabled()) // debug after adding as adding changes
													// path/ id
				{
					log.debug("Added autolink " + component);
				}
			}

			// Failed to find it?
			if (component != null)
			{
				if (log.isDebugEnabled())
				{
					log.debug("Begin render of sub-component " + component);
				}

				component.render(cycle);

				if (log.isDebugEnabled())
				{
					log.debug("End render of sub-component " + component);
				}
			}
			else
			{
				// If it's a [body] tag
				if (componentName.equals("[body]"))
				{
					if (!markupStream.atOpenCloseTag())
					{
						markupStream.throwMarkupException("A [body] tag must be an openclose tag.");
					}
					// Render the children tag
					renderTag(cycle, tag);
					markupStream.next();

					// Find nearest Border at or above this container
					Border border = (Border) ((this instanceof Border) ? this : findParent(Border.class));

					// If markup stream is null, that indicates we already
					// recursed into
					// this block of log and set it to null (below). If we did
					// that,
					// then we want to go up another level of border nesting.
					if (border.getMarkupStream() == null)
					{
						// Find Border at or above parent of this border
						Container borderParent = border.getParent();

						border = (Border) ((borderParent instanceof Border) ? borderParent : borderParent
								.findParent(Border.class));
					}

					// Get the border's markup
					final MarkupStream borderMarkup = border.findMarkupStream();

					// Set markup of border to null. This allows us to find the
					// border's
					// parent's markup. It also indicates that we've been here
					// in the log
					// just above.
					border.setMarkupStream(null);

					// Draw the children of the border component using its
					// original in-line
					// markup stream (not the border's associated markup stream)
					border.renderBody(cycle, border.findMarkupStream(), border.getOpenTag());

					// Restore border markup so it can continue rendering
					border.setMarkupStream(borderMarkup);
				}
				else
				{
					markupStream.throwMarkupException("Unable to find component named '" + componentName + "' in "
							+ this);
				}
			}
		}
		else
		{
			// Render as raw markup
			log.debug("Rendering raw markup");
			cycle.getResponse().write(element.toString());
			markupStream.next();
		}
	}

