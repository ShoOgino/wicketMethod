	/**
	 * Maps the specified <code>key</code> to the specified <code>value</code>
	 * in this table. Neither the key nor the value can be <code>null</code>.
	 * (Note that this policy is the same as for java.util.Hashtable, but unlike
	 * java.util.HashMap, which does accept nulls as valid keys and values.)
	 * <p>
	 * 
	 * The value can be retrieved by calling the <code>get</code> method with
	 * a key that is equal to the original key.
	 * 
	 * @param key
	 *            the table key.
	 * @param value
	 *            the value.
	 * @return the previous value of the specified key in this table, or
	 *         <code>null</code> if it did not have one.
	 * @exception NullPointerException
	 *                if the key or value is <code>null</code>.
	 * @see Object#equals(Object)
	 * @see #get(Object)
	 */
	public Object put(Object key, Object value)
	{
		if (value == null)
		{
			throw new IllegalArgumentException("Value must not be null");
		}
		int hash = hash(key);
		Segment seg = segments[hash & SEGMENT_MASK];
		int segcount;
		Entry[] tab;
		int votes;

		synchronized (seg)
		{
			tab = table;
			int index = hash & (tab.length - 1);
			Entry first = tab[index];

			for (Entry e = first; e != null; e = e.next)
			{
				if (e.hash == hash && eq(key, e.key))
				{
					Object oldValue = e.value;
					e.value = value;
					return oldValue;
				}
			}

			// Add to front of list
			Entry newEntry = new Entry(hash, key, value, first);
			tab[index] = newEntry;

			if ((segcount = ++seg.count) < threshold)
				return null;

			int bit = (1 << (hash & SEGMENT_MASK));
			votes = votesForResize;
			if ((votes & bit) == 0)
				votes = votesForResize |= bit;
		}

		// Attempt resize if 1/4 segs vote,
		// or if this seg itself reaches the overall threshold.
		// (The latter check is just a safeguard to avoid pathological cases.)
		if (bitcount(votes) >= CONCURRENCY_LEVEL / 4 || segcount > (threshold * CONCURRENCY_LEVEL))
			resize(0, tab);

		return null;
	}

