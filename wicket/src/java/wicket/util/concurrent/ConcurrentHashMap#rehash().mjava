	/**
	 * Rehashes the contents of this map into a new table with a larger
	 * capacity.
	 */
	protected void rehash()
	{
		votesForResize = 0; // reset

		Entry[] oldTable = table;
		int oldCapacity = oldTable.length;

		if (oldCapacity >= MAXIMUM_CAPACITY)
		{
			threshold = Integer.MAX_VALUE; // avoid retriggering
			return;
		}

		int newCapacity = oldCapacity << 1;
		Entry[] newTable = newTable(newCapacity);
		int mask = newCapacity - 1;

		/*
		 * Reclassify nodes in each list to new Map. Because we are using
		 * power-of-two expansion, the elements from each bin must either stay
		 * at same index, or move to oldCapacity+index. We also eliminate
		 * unnecessary node creation by catching cases where old nodes can be
		 * reused because their next fields won't change. Statistically, at the
		 * default threshhold, only about one-sixth of them need cloning. (The
		 * nodes they replace will be garbage collectable as soon as they are no
		 * longer referenced by any reader thread that may be in the midst of
		 * traversing table right now.)
		 */

		for (int i = 0; i < oldCapacity; i++)
		{
			// We need to guarantee that any existing reads of old Map can
			// proceed. So we cannot yet null out each bin.
			Entry e = oldTable[i];

			if (e != null)
			{
				int idx = e.hash & mask;
				Entry next = e.next;

				// Single node on list
				if (next == null)
					newTable[idx] = e;

				else
				{
					// Reuse trailing consecutive sequence of all same bit
					Entry lastRun = e;
					int lastIdx = idx;
					for (Entry last = next; last != null; last = last.next)
					{
						int k = last.hash & mask;
						if (k != lastIdx)
						{
							lastIdx = k;
							lastRun = last;
						}
					}
					newTable[lastIdx] = lastRun;

					// Clone all remaining nodes
					for (Entry p = e; p != lastRun; p = p.next)
					{
						int k = p.hash & mask;
						newTable[k] = new Entry(p.hash, p.key, p.value, newTable[k]);
					}
				}
			}
		}

		table = newTable;
	}

