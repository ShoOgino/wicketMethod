	/**
	 * Reattach this component to its parent.
	 * <p>
	 * Consider the case where you have multiple possibilities of a panel. You
	 * code could look like (very simplified):
	 * 
	 * <pre>
	 * MyFooPanel p1 = new MyFooPanel(this, &quot;panel&quot;);
	 * MyBarPanel p2 = new MyBarPanel(this, &quot;panel&quot;);
	 * </pre>
	 * 
	 * where this could be the page or panel or whatever parent the panel is
	 * added to.
	 * </p>
	 * <p>
	 * In the above example, <code>p2</code> is constructed last, but with the
	 * same id as <code>p1</code>, so <code>p2</code> would be the 'active'
	 * one/ the component that will be rendered. When <code>p2</code> is
	 * added, the component it is added to will recognize that it already had a
	 * component with the same id (<code>p1</code>), and will replace that
	 * component with the newer one (<code>p2</code>).
	 * </p>
	 * <p>
	 * Say if you wanted to just pre-create those panels, but set
	 * <code>p1</code> as the active one, you could call {@link #reAttach()}
	 * on <code>p1</code>:
	 * 
	 * <pre>
	 * MyFooPanel p1 = new MyFooPanel(this, &quot;panel&quot;);
	 * MyBarPanel p2 = new MyBarPanel(this, &quot;panel&quot;);
	 * p1.reAttach();
	 * </pre>
	 * 
	 * which triggers that <code>p1</code> is set as the current child with id
	 * <code>panel</code>.
	 * </p>
	 * <p>
	 * As you probably got from the above example, you would typically use
	 * {@link #reAttach()} when you have previously created components that were
	 * replaced (or you suspect that they <i>might</i> be replaced... you can
	 * always call {@link #reAttach} even if it is the current child) but you
	 * want to set them as the current one.
	 * </p>
	 * 
	 * @return This
	 */
	public final Component reAttach()
	{
		if (getFlag(FLAG_REMOVED_FROM_PARENT) == true)
		{
			if (id.startsWith(AUTO_COMPONENT_PREFIX))
			{
				parent.autoAdd(this);
			}
			else
			{
				parent.add(this);
			}
		}
		return this;
	}

