	/**
	 * Throw an exception if not all components rendered.
	 * 
	 * @param renderedContainer
	 *            The page itself if it was a full page render or the container that was rendered
	 *            standalone
	 */
	private final void checkRendering(final MarkupContainer renderedContainer)
	{
		// If the application wants component uses checked and
		// the response is not a redirect
		final IDebugSettings debugSettings = Application.get().getDebugSettings();
		if (debugSettings.getComponentUseCheck())
		{
			final List<Component> unrenderedComponents = new ArrayList<Component>();
			final StringBuffer buffer = new StringBuffer();
			renderedContainer.visitChildren(new IVisitor<Component>()
			{
				public Object component(final Component component)
				{
					// If component never rendered
					if (renderedComponents == null || !renderedComponents.contains(component))
					{
						// If not an auto component ...
						if (!component.isAuto() && component.isVisibleInHierarchy())
						{
							// Increase number of unrendered components
							unrenderedComponents.add(component);

							// Add to explanatory string to buffer
							buffer.append(Integer.toString(unrenderedComponents.size()) + ". " +
								component + "\n");
							String metadata = component.getMetaData(Component.CONSTRUCTED_AT_KEY);
							if (metadata != null)
							{
								buffer.append(metadata);
							}
							metadata = component.getMetaData(Component.ADDED_AT_KEY);
							if (metadata != null)
							{
								buffer.append(metadata);
							}
						}
						else
						{
							// if the component is not visible in hierarchy we
							// should not visit its children since they are also
							// not visible
							return CONTINUE_TRAVERSAL_BUT_DONT_GO_DEEPER;
						}
					}
					return CONTINUE_TRAVERSAL;
				}
			});

			// Throw exception if any errors were found
			if (unrenderedComponents.size() > 0)
			{
				// Get rid of set
				renderedComponents = null;

				List<Component> transparentContainerChildren = new ArrayList<Component>();

				Iterator<Component> iterator = unrenderedComponents.iterator();
				outerWhile : while (iterator.hasNext())
				{
					Component component = iterator.next();

					// If any of the transparentContainerChildren is a parent to component, than
					// ignore it.
					for (Component transparentContainerChild : transparentContainerChildren)
					{
						MarkupContainer parent = component.getParent();
						while (parent != null)
						{
							if (parent == transparentContainerChild)
							{
								iterator.remove();
								continue outerWhile;
							}
							parent = parent.getParent();
						}
					}

					// Now first test if the component has a sibling that is a transparent resolver.
					Iterator<? extends Component> iterator2 = component.getParent().iterator();
					while (iterator2.hasNext())
					{
						Component sibling = iterator2.next();
						if (!sibling.isVisible())
						{
							if (sibling instanceof IComponentResolver)
							{
								// we found a transparent container that isn't visible
								// then ignore this component and only do a debug statement here.
								if (log.isDebugEnabled())
								{
									log.debug(
										"Component {} wasn't rendered but most likely it has a transparent parent: {}",
										component, sibling);
								}
								transparentContainerChildren.add(component);
								iterator.remove();
								continue outerWhile;
							}
						}
					}
				}
				// if still > 0
				if (unrenderedComponents.size() > 0)
				{
					// Throw exception
					throw new WicketRuntimeException(
						"The component(s) below failed to render. A common problem is that you have added a component in code but forgot to reference it in the markup (thus the component will never be rendered).\n\n" +
							buffer.toString());
				}
			}
		}

		// Get rid of set
		renderedComponents = null;
	}

