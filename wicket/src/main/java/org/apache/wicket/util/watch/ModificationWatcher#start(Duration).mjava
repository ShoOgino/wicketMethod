	/**
	 * @see org.apache.wicket.util.watch.IModificationWatcher#start(org.apache.wicket.util.time.Duration)
	 */
	public void start(final Duration pollFrequency)
	{
		// Construct task with the given polling frequency
		task = new Task("ModificationWatcher");

		task.run(pollFrequency, new ICode()
		{
			public void run(final Logger log)
			{
				// Iterate over a copy of the list of entries to avoid concurrent modification
				// problems without the associated liveness issues of holding a lock while
				// potentially polling file times!
				Iterator<Entry> iter = new ArrayList<Entry>(modifiableToEntry.values()).iterator();
				while (iter.hasNext())
				{
					final Entry entry = iter.next();

					// If the modifiable has been modified after the last known
					// modification time
					final Time modifiableLastModified = entry.modifiable.lastModifiedTime();
					if ((modifiableLastModified != null) &&
						modifiableLastModified.after(entry.lastModifiedTime))
					{
						// Notify all listeners that the modifiable was modified
						entry.listeners.notifyListeners();

						// Update timestamp
						entry.lastModifiedTime = modifiableLastModified;
					}
				}
			}
		});
	}

