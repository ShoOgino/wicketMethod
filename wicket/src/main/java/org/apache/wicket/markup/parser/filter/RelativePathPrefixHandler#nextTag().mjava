	/**
	 * Get the next MarkupElement from the parent MarkupFilter and handle it if the specific filter
	 * criteria are met. Depending on the filter, it may return the MarkupElement unchanged,
	 * modified or it remove by asking the parent handler for the next tag.
	 * 
	 * @see org.apache.wicket.markup.parser.IMarkupFilter#nextTag()
	 * @return Return the next eligible MarkupElement
	 */
	public MarkupElement nextTag() throws ParseException
	{
		// Get the next tag. If null, no more tags are available
		final ComponentTag tag = (ComponentTag)getParent().nextTag();
		if ((tag == null) || tag.isClose())
		{
			return tag;
		}

		// Don't touch any wicket:id component and any auto-components
		if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true) ||
			(tag.getAttributes().get("wicket:id") != null))
		{
			return tag;
		}

		// Work out whether we have any attributes that require us to add a
		// behavior that prepends the relative path.
		for (int i = 0; i < attributeNames.length; i++)
		{
			String attrName = attributeNames[i];
			String attrValue = tag.getAttributes().getString(attrName);
			if ((attrValue != null) && (attrValue.startsWith("/") == false) &&
				(attrValue.indexOf(":") < 0) && !(attrValue.startsWith("#")))
			{
				if (tag.getId() == null)
				{
					tag.setId(WICKET_RELATIVE_PATH_PREFIX_CONTAINER_ID);
					tag.setAutoComponentTag(true);
				}
				tag.addBehavior(RELATIVE_PATH_BEHAVIOR);
				tag.setModified(true);
				break;
			}
		}

		return tag;
	}

