	/**
	 * @see org.apache.wicket.markup.IMarkupFragment#findComponentIndex(java.lang.String,
	 *      java.lang.String, int)
	 */
	public final int findComponentIndex(final String path, final String id, final int startIndex)
	{
		if ((id == null) || (id.length() == 0))
		{
			throw new IllegalArgumentException("Parameter 'id' must not be null");
		}

		// TODO Post 1.2: A component path e.g. "panel:label" does not match 1:1
		// with the markup in case of ListView, where the path contains a number
		// for each list item. E.g. list:0:label. What we currently do is simply
		// remove the number from the path and hope that no user uses an integer
		// for a component id. This is a hack only. A much better solution would
		// delegate to the various components recursively to search within there
		// realm only for the components markup. ListItems could then simply
		// do nothing and delegate to their parents.
		String completePath = (path == null || path.length() == 0 ? id : path + ":" + id);

		// s/:\d+//g
		Pattern re = Pattern.compile(":\\d+");
		Matcher matcher = re.matcher(completePath);
		completePath = matcher.replaceAll("");

		// All component tags are registered with the cache
		if (componentMap != null)
		{
			final Integer value = componentMap.get(completePath);
			if (value != null)
			{
				// return the components position in the markup stream
				return value.intValue();
			}
		}

		for (int i = Math.max(0, startIndex); i < size(); i++)
		{
			MarkupElement elem = get(i);
			if (elem instanceof ComponentTag)
			{
				ComponentTag tag = (ComponentTag)elem;
				if (tag.isAutoComponentTag() && (tag.getId() != null) && tag.getId().startsWith(id))
				{
					return i;
				}
			}
		}

		return -1;
	}

