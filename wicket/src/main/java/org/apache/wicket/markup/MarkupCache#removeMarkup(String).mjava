	public final IMarkupFragment removeMarkup(final String cacheKey)
	{
		Args.notNull(cacheKey, "cacheKey");

		if (log.isDebugEnabled())
		{
			log.debug("Remove from cache: cacheKey=" + cacheKey);
		}

		// Remove the markup from the cache
		CharSequence locationString = markupKeyCache.get(cacheKey);
		IMarkupFragment markup = markupCache.get(locationString);
		if (markup != null)
		{
			markupCache.remove(locationString);

			// If a base markup file has been removed from the cache, than
			// the derived markup should be removed as well.

			// Repeat until all depend resources have been removed (count == 0)
			int count;
			do
			{
				count = 0;

				// Iterate though all entries of the cache
				Iterator<CharSequence> iter = markupCache.getKeys().iterator();
				while (iter.hasNext())
				{
					CharSequence key = iter.next();

					// Check if the markup associated with key has a base markup. And if yes, test
					// if that is cached.
					if (isBaseMarkupCached(key))
					{
						if (log.isDebugEnabled())
						{
							log.debug("Remove from cache: cacheKey=" + key);
						}

						iter.remove();
						count++;
					}
				}
			}
			while (count > 0);

			// And now remove all watcher entries associated with markup
			// resources no longer in the cache. Note that you can not use
			// Application.get() since removeMarkup() will be called from a
			// ModificationWatcher thread which has no associated Application.
			IModificationWatcher watcher = application.getResourceSettings().getResourceWatcher(
				true);
			if (watcher != null)
			{
				Iterator<IModifiable> iter = watcher.getEntries().iterator();
				while (iter.hasNext())
				{
					IModifiable modifiable = iter.next();
					if (modifiable instanceof MarkupResourceStream)
					{
						if (isMarkupCached((MarkupResourceStream)modifiable))
						{
							iter.remove();
						}
					}
				}
			}
		}
		return markup;
	}

