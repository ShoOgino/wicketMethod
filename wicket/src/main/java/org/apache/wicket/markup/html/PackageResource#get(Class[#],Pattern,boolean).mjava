	/**
	 * Gets non-localized resources for a given set of criteria. Multiple resource can be loaded for
	 * the same criteria if they match the pattern. If no resources were found, this method returns
	 * null.
	 * 
	 * @param scope
	 *            This argument will be used to get the class loader for loading the package
	 *            resource, and to determine what package it is in. Typically this is the calling
	 *            class/ the class in which you call this method
	 * @param pattern
	 *            Regexp pattern to match resources
	 * @param recurse
	 *            Whether this method should recurse into sub packages
	 * @return The resources, never null but may be empty
	 * @deprecated Will be removed in 2.0; contribute resources one by one instead
	 */
	@Deprecated
	public static PackageResource[] get(Class< ? > scope, Pattern pattern, boolean recurse)
	{
		final List resources = new ArrayList();
		String packageRef = Strings.replaceAll(PackageName.forClass(scope).getName(), ".", "/")
			.toString();
		ClassLoader loader = scope.getClassLoader();
		try
		{
			// loop through the resources of the package
			Enumeration packageResources = loader.getResources(packageRef);
			while (packageResources.hasMoreElements())
			{
				URL resource = (URL)packageResources.nextElement();
				URLConnection connection = resource.openConnection();
				if (connection instanceof JarURLConnection)
				{
					JarFile jf = ((JarURLConnection)connection).getJarFile();
					scanJarFile(scope, pattern, recurse, resources, packageRef, jf);
				}
				else
				{
					String absolutePath = scope.getResource("").toExternalForm();
					File basedir;
					URI uri;
					try
					{
						uri = new URI(absolutePath);
					}
					catch (URISyntaxException e)
					{
						throw new RuntimeException(e);
					}
					try
					{
						basedir = new File(uri);
					}
					catch (IllegalArgumentException e)
					{
						log.debug("Can't construct the uri as a file: " + absolutePath);
						// if this is thrown then the path is not really a
						// file. but could be a zip.
						String jarZipPart = uri.getSchemeSpecificPart();
						// lowercased for testing if jar/zip, but leave the real
						// filespec unchanged
						String lowerJarZipPart = jarZipPart.toLowerCase();
						int index = lowerJarZipPart.indexOf(".zip");
						if (index == -1)
						{
							index = lowerJarZipPart.indexOf(".jar");
						}
						if (index == -1)
						{
							throw e;
						}

						String filename = jarZipPart.substring(0, index + 4); // 4 =
						// len of ".jar" or ".zip"
						log.debug("trying the filename: " + filename + " to load as a zip/jar.");
						JarFile jarFile = new JarFile(filename, false);
						scanJarFile(scope, pattern, recurse, resources, packageRef, jarFile);
						return (PackageResource[])resources.toArray(new PackageResource[resources.size()]);
					}
					if (!basedir.isDirectory())
					{
						throw new IllegalStateException("unable to read resources from directory " +
							basedir);
					}
				}
			}
		}
		catch (IOException e)
		{
			throw new WicketRuntimeException(e);
		}

		return (PackageResource[])resources.toArray(new PackageResource[resources.size()]);
	}

