	/**
	 * Clean up the request cycle.
	 */
	private void detach()
	{
		for (IRequestTarget target : requestTargets)
		{
			if (target != null)
			{
				try
				{
					target.detach(this);
				}
				catch (RuntimeException e)
				{
					log.error("there was an error cleaning up target " + target + ".", e);
				}
			}
		}

		// remove any rendered feedback messages from the session
		try
		{
			session.cleanupFeedbackMessages();
		}
		catch (RuntimeException re)
		{
			log.error("there was an error cleaning up feedback messages for session " + session
					+ ".", re);
		}

		if (updateSession)
		{
			// At the end of our response, we need to set any session
			// attributes that might be required to update the cluster
			try
			{
				session.update();
			}
			catch (RuntimeException re)
			{
				log.error("there was an error updating the session " + session + ".", re);
			}
		}

		// clear the used pagemap for this thread,
		// maybe we can move this a few lines above to have a but more
		// concurrency (session.update)
		try
		{
			session.requestDetached();
		}
		catch (RuntimeException re)
		{
			log.error("there was an error detaching request from session " + session + ".", re);
		}

		if (getResponse() instanceof BufferedWebResponse)
		{
			try
			{
				((BufferedWebResponse)getResponse()).filter();
			}
			catch (RuntimeException re)
			{
				log.error("there was an error filtering the response.", re);
			}
		}

		try
		{
			getApplication().getSessionStore().onEndRequest(request);

			onEndRequest();
		}
		catch (RuntimeException e)
		{
			log.error("Exception occurred during request detachement", e);
		}


		IRequestLogger requestLogger = getApplication().getRequestLogger();
		if (requestLogger != null)
		{
			requestLogger.requestTime((System.currentTimeMillis() - startTime));
		}

		// Release thread local resources
		threadDetach();
	}

