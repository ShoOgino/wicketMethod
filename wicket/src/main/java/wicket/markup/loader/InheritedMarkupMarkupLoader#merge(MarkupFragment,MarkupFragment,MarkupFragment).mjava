	/**
	 * Merge inherited and base markup.
	 * 
	 * @param derivedMarkup
	 *            The derived markup
	 * @param baseMarkup
	 *            The base markup
	 * @param extendFragment
	 *            The <wicket:extend> markup fragment
	 * @return The merged markup
	 */
	private MarkupFragment merge(final MarkupFragment derivedMarkup,
			final MarkupFragment baseMarkup, final MarkupFragment extendFragment)
	{
		// Creating the merged markup starts with makeing a modifiable copy of
		// the base markup
		MarkupFragment mergedMarkup = baseMarkup.makeCopy();

		// Search for wicket:child. Make sure it is the wicket:child of the base
		// markup and not the base-base markup
		{
			final MarkupFragment childFragment = MarkupFragmentUtils
					.getWicketChildTag(mergedMarkup);
			if (childFragment == null)
			{
				throw new MarkupException(new MarkupStream(baseMarkup),
						"Didn't find <wicket:child> tag in base markup. Markup: "
								+ baseMarkup.toUserDebugString());
			}

			// Convert the body tag into open-body-close if necessary
			if (childFragment.getTag().isOpenClose())
			{
				ComponentTag bodyTag = childFragment.getTag().mutable();
				bodyTag.setType(XmlTag.Type.OPEN);
				bodyTag.makeImmutable();

				ComponentTag bodyCloseTag = bodyTag.mutable();
				bodyCloseTag.setType(XmlTag.Type.CLOSE);

				childFragment.removeMarkupElement(0);
				childFragment.addMarkupElement(bodyTag);
				childFragment.addMarkupElement(bodyCloseTag);
			}
			else
			{
				// Remove preview area
				// TODO check that only raw markup is removed
				while (childFragment.size() > 2)
				{
					childFragment.visitChildren(MarkupFragment.class, new MarkupFragment.IVisitor()
					{
						public Object visit(MarkupElement element, MarkupFragment parent)
						{
							MarkupStream markupStream = new MarkupStream(baseMarkup);
							while (markupStream.hasMore())
							{
								if (markupStream.next() == childFragment)
								{
									break;
								}
							}
							
							throw new MarkupException(markupStream,
									"No wicket components are allowed in the preview area in between the wicket:child tag");
						}
					});
					childFragment.removeMarkupElement(1);
				}
			}

			// copy wicket:extend into the body
			childFragment.addMarkupElement(1, extendFragment.makeCopy());
		}

		{
			// Get the body fragment from the derived markup
			MarkupFragment body1 = MarkupFragmentUtils.getBodyTag(derivedMarkup);
			if (body1 != null)
			{
				// Get the body fragment from the merged markup
				MarkupFragment body2 = MarkupFragmentUtils.getBodyTag(mergedMarkup);

				// Append the onload and onunload attributes
				ComponentTag newBodyTag = body2.getTag().mutable();

				String onload = Strings.join(";", newBodyTag.getAttributes().getString(ONLOAD),
						body1.getTag().getAttributes().getString(ONLOAD));

				String onunload = Strings.join(";", newBodyTag.getAttributes().getString(ONUNLOAD),
						body1.getTag().getAttributes().getString(ONUNLOAD));

				if (Strings.isEmpty(onload) == false)
				{
					newBodyTag.put(ONLOAD, onload);
				}

				if (Strings.isEmpty(onunload) == false)
				{
					newBodyTag.put(ONUNLOAD, onunload);
				}

				body2.removeMarkupElement(0);
				body2.addMarkupElement(0, newBodyTag);
			}
		}

		{
			// Copy wicket:head from derived markup
			// First get all wicket:head tags from the derived markup
			final List<MarkupFragment> headers = MarkupFragmentUtils
					.getWicketHeaders(derivedMarkup);

			// Now add them to the merged markup
			if (headers != null)
			{
				// Find the proper location
				MarkupFragmentUtils.LookupResult result = null;

				// If merged markup contains <wicket:head> already, than append
				// them
				// to the end
				result = MarkupFragmentUtils.getWicketHeadTagPosition(mergedMarkup);

				// Else, if markup contains <head>, than insert before the close
				// tag
				if (result == null)
				{
					result = MarkupFragmentUtils.getHeadTagPosition(mergedMarkup);
				}

				// Else, if markup contains <body>, than insert before the body
				// tag
				if (result == null)
				{
					result = MarkupFragmentUtils.getBodyTagPosition(mergedMarkup);
				}

				// Else, insert right at the beginning
				if (result == null)
				{
					// remove "empty" root fragment
					if ((mergedMarkup.size() == 1)
							&& (mergedMarkup.get(0) instanceof MarkupFragment))
					{
						mergedMarkup = (MarkupFragment)mergedMarkup.get(0);
					}

					result = new MarkupFragmentUtils.LookupResult(mergedMarkup, 0);
				}

				// Copy the header(s)
				if (result != null)
				{
					for (MarkupFragment fragment : headers)
					{
						result.fragment.addMarkupElement(result.index++, fragment);
					}
				}
			}
		}

		// If the markup contains wicket:head but no <head> than automatically
		// insert it.
		if (Page.class.isAssignableFrom(mergedMarkup.getMarkup().getResource().getContainerInfo()
				.getContainerClass()))
		{
			// If no <head>, than ...
			if (MarkupFragmentUtils.getHeadTag(mergedMarkup) == null)
			{
				// Search for <wicket:head>
				MarkupFragmentUtils.LookupResult result = MarkupFragmentUtils
						.getWicketHeadTagPosition(mergedMarkup);
				if (result != null)
				{
					ComponentTag openTag = new ComponentTag(new XmlTag());
					openTag.setName("head");
					openTag.setId(HtmlHeaderSectionHandler.HEADER_ID);
					openTag.setType(XmlTag.Type.OPEN);
					openTag.makeImmutable();

					ComponentTag closeTag = openTag.mutable();
					closeTag.setType(XmlTag.Type.CLOSE);
					closeTag.setOpenTag(openTag);

					MarkupFragment headerFragment = new MarkupFragment(result.fragment.getMarkup());
					headerFragment.addMarkupElement(openTag);
					headerFragment.addMarkupElement(closeTag);

					result.fragment.addMarkupElement(1, headerFragment);

					// Apply a simplistic approach. If more control is required,
					// ask the user should add a <head> tag. The simplistic
					// approach assumes that all wicket:head tags are in
					// sequence.
					while (result.index < result.fragment.size())
					{
						MarkupElement elem = result.fragment.get(result.index);
						if (elem instanceof MarkupFragment)
						{
							ComponentTag tag = ((MarkupFragment)elem).getTag();
							if (tag.isWicketHeadTag())
							{
								headerFragment.addMarkupElement(headerFragment.size() - 1, elem);
								result.fragment.removeMarkupElement(result.index);
							}
							else
							{
								break;
							}
						}
						else
						{
							break;
						}
					}
				}
			}
		}

		// remove "empty" root fragment
		if ((mergedMarkup.size() == 1) && (mergedMarkup.get(0) instanceof MarkupFragment))
		{
			mergedMarkup = (MarkupFragment)mergedMarkup.get(0);
		}

		// This is only needed as long as the old Header Container code exists
		// TODO remove when no longer needed. See
		// WebMarkupContainerWithAssociatedMarkup#renderHeadFromAssociatedMarkupFile()
		mergedMarkup.visitChildren(ComponentTag.class, new MarkupFragment.IVisitor()
		{
			public Object visit(final MarkupElement element, final MarkupFragment parent)
			{
				ComponentTag tag = (ComponentTag)element;
				tag.setMarkupClass(parent.getMarkup().getResource().getMarkupClass());
				return CONTINUE_TRAVERSAL;
			}
		});

		return mergedMarkup;
	}

