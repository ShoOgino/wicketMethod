	/**
	 * Scans the given markup and extracts balancing tags.
	 * 
	 * @return The markup associated with the resource
	 */
	private MarkupFragment parseMarkup()
	{
		this.markupElements = new ArrayList<MarkupElement>(20);

		try
		{
			// always remember the latest index (size)
			int size = this.markupElements.size();

			// Loop through tags
			for (ComponentTag tag; null != (tag = (ComponentTag)this.markupFilterChain.nextTag());)
			{
				boolean add = (tag.getId() != null);
				if (!add && tag.getXmlTag().isClose())
				{
					add = ((tag.getOpenTag() != null) && (tag.getOpenTag().getId() != null));
				}

				// Add tag to list?
				if (add || tag.isModified())
				{
					final CharSequence text = this.xmlParser.getInputFromPositionMarker(tag
							.getPos());

					// Add text from last position to tag position
					if (text.length() > 0)
					{
						String rawMarkup = text.toString();

						if (this.stripComments)
						{
							rawMarkup = removeComment(rawMarkup);
						}

						if (this.compressWhitespace)
						{
							rawMarkup = compressWhitespace(rawMarkup);
						}

						// Make sure you add it at the correct location.
						// IMarkupFilters might have added elements as well.
						this.markupElements.add(size, new RawMarkup(rawMarkup));
					}

					if (add)
					{
						// Add to list unless preview component tag remover
						// flagged as removed
						if (!WicketRemoveTagHandler.IGNORE.equals(tag.getId()))
						{
							this.markupElements.add(tag);
						}
					}
					else if (tag.isModified())
					{
						this.markupElements.add(new RawMarkup(tag.toCharSequence()));
					}

					this.xmlParser.setPositionMarker();
				}

				// allways remember the latest index (size)
				size = this.markupElements.size();
			}
		}
		catch (final ParseException ex)
		{
			int size = this.markupElements.size();

			// Add remaining input string
			final CharSequence text = this.xmlParser.getInputFromPositionMarker(-1);
			if (text.length() > 0)
			{
				this.markupElements.add(new RawMarkup(text));
			}

			this.markup.setEncoding(this.xmlParser.getEncoding());
			this.markup.setXmlDeclaration(this.xmlParser.getXmlDeclaration());

			// Create a MarkupStream and position it at the error location
			for (MarkupElement elem : this.markupElements)
			{
				this.rootFragment.addMarkupElement(elem);
			}
			MarkupStream markupStream = new MarkupStream(this.rootFragment);
			markupStream.setCurrentIndex(size);

			throw new MarkupException(markupStream, ex.getMessage(), ex);
		}

		// Add tail?
		final CharSequence text = this.xmlParser.getInputFromPositionMarker(-1);
		if (text.length() > 0)
		{
			String rawMarkup = text.toString();

			if (this.stripComments)
			{
				rawMarkup = removeComment(rawMarkup);
			}

			if (this.compressWhitespace)
			{
				rawMarkup = compressWhitespace(rawMarkup);
			}

			this.markupElements.add(new RawMarkup(rawMarkup));
		}

		// Convert the list into a MarkupFragment tree
		if (this.markupElements.size() > 0)
		{
			Stack<MarkupFragment> stack = new Stack<MarkupFragment>();
			stack.push(this.rootFragment);
			MarkupFragment currentFragment = this.rootFragment;

			for (MarkupElement elem : this.markupElements)
			{
				if (elem instanceof RawMarkup)
				{
					currentFragment.addMarkupElement(elem);
				}
				else
				{
					ComponentTag tag = (ComponentTag)elem;
					if (tag.isOpen() || tag.isOpenClose())
					{
						// Push the current markup fragment on the stack
						stack.push(currentFragment);

						// and create a new MarkupFragment
						MarkupFragment newFragment = new MarkupFragment(this.rootFragment
								.getMarkup());

						// add the new fragment to its parent
						currentFragment.addMarkupElement(newFragment);

						// make the new fragment the current one
						currentFragment = newFragment;
					}

					// Add the tag to the fragment
					currentFragment.addMarkupElement(tag);

					// If required "close" the fragment and continue with the
					// parent fragment
					if (tag.isOpenClose() || tag.isClose() || tag.hasNoCloseTag())
					{
						currentFragment = stack.pop();
					}
				}
			}
			
			// Avoid an "empty" root fragment. Return the first fragment instead
			if (this.rootFragment.size() == 1)
			{
				MarkupElement elem = this.rootFragment.get(0);
				if (elem instanceof MarkupFragment)
				{
					return (MarkupFragment) elem;
				}
			}
		}

		return this.rootFragment;
	}

