	/**
	 * Encode the given request target. If a mount is found, that mounted url
	 * will be returned. Otherwise, one of the delegation methods will be
	 * called. In case you are using custom targets that are not part of the
	 * default target hierarchy, you need to override
	 * {@link #doEncode(RequestCycle, IRequestTarget)}, which will be called
	 * after the defaults have been tried. When that doesn't provide a url
	 * either, and exception will be thrown saying that encoding could not be
	 * done.
	 * 
	 * @see wicket.request.IRequestCodingStrategy#encode(wicket.RequestCycle,
	 *      wicket.IRequestTarget)
	 */
	public final CharSequence encode(final RequestCycle requestCycle,
			final IRequestTarget requestTarget, final boolean absolutePath)
	{
		// First check to see whether the target is mounted
		CharSequence url = pathForTarget(requestTarget);
		
		if (url != null) {
			// Do nothing - we've found the URL and it's mounted.
		}
		else if (requestTarget instanceof IBookmarkablePageRequestTarget)
		{
			url = encode(requestCycle, (IBookmarkablePageRequestTarget)requestTarget);
		}
		else if (requestTarget instanceof ISharedResourceRequestTarget)
		{
			url = encode(requestCycle, (ISharedResourceRequestTarget)requestTarget);
		}
		else if (requestTarget instanceof IListenerInterfaceRequestTarget)
		{
			url = encode(requestCycle, (IListenerInterfaceRequestTarget)requestTarget);
		}
		else if (requestTarget instanceof IPageRequestTarget)
		{
			// This calls page.urlFor(IRedirectListener.INTERFACE), which calls
			// the function we're in again. We therefore need to jump out here and
			// return the url immediately, otherwise we end up prefixing it with
			// relative path or absolute prefixes twice.
			url = encode(requestCycle, (IPageRequestTarget)requestTarget);
			return url;
		}
		// fallthough for non-default request targets
		else
		{
			url = doEncode(requestCycle, requestTarget);
		}
		
		if (url != null)
		{
			String rootPath = ((WebApplication)Application.get()).getRootPath();
			String filterPath = ((WebApplication)Application.get()).getFilterPath();
			
			// Strip off leading / (for custom encodes or mounted resources/pages)
			if (url.length() > 0 && url.charAt(0) == '/')
			{
				url = url.subSequence(1, url.length());
			}
			
			// If we're doing a 302-redirect, prepend the root path
			if (absolutePath)
			{
				if (rootPath.endsWith("/") || url.length() > 0 && url.charAt(0) == '?')
				{
					url = rootPath + url;
				}
				else
				{
					url = rootPath + "/" + url;
				}
				return requestCycle.getOriginalResponse().encodeURL(url);
			}

			String relativeUrl = requestCycle.getRequest().getRelativeURL();
			String segments = "";
			for (int i = 0; i < relativeUrl.length(); i++)
			{
				if (relativeUrl.charAt(i) == '?')
				{
					break;
				}
				if (relativeUrl.charAt(i) == '/')
				{
					segments += "../";
				}
			}
			PrependingStringBuffer prepender = new PrependingStringBuffer();
			
			prepender.prepend(url.toString());
			if (url.length() > 0 && (url.charAt(0) == '?' || url.charAt(0) == ';'))
			{
				if (segments.length() == 0 && filterPath.length() == 0) {
					prepender.prepend("./");
				}
			}
			else if (filterPath.length() > 0)
			{
				prepender.prepend('/');
			}
			prepender.prepend(filterPath);
			if (segments.length() > 0) {
				prepender.prepend(segments);
			}
			return requestCycle.getOriginalResponse().encodeURL(prepender.toString());
		}
		
		// Just return null intead of throwing an exception. So that it can be
		// handled better
		return null;
	}

