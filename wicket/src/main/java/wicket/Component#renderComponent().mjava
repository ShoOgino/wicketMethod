	/**
	 * Page.renderPage() is used to render a whole page. With AJAX however it
	 * must be possible to render any one component contained in a page. That is
	 * what this method is for.
	 * <p>
	 * Note: it is not necessary that the page has previously been rendered. But
	 * the component must have been added (directly or indirectly) to a
	 * container with an associated markup file (Page, Panel or Border).
	 */
	public final void renderComponent()
	{
		// If this Component is a Page
		if (this instanceof Page)
		{
			// Render as Page, with all the special logic that entails
			((Page)this).renderPage();
		}
		else
		{
			// Save the parent's markup stream to re-assign it at the end
			MarkupContainer parent = getParent();
			MarkupStream originalMarkupStream = parent.getMarkupStream();
			MarkupStream markupStream = new MarkupFragmentFinder().find(this);

			try
			{
				// Make sure that while rendering the markup stream is found
				parent.setMarkupStream(markupStream);

				if (this instanceof MarkupContainer)
				{
					MarkupContainer container = (MarkupContainer)this;

					// First, give priority to IFeedback instances, as they have
					// to
					// collect their messages before components like ListViews
					// remove any child components
					container.visitChildren(IFeedback.class, new IVisitor()
					{
						public Object component(Component component)
						{
							((IFeedback)component).updateFeedback();
							component.internalAttach();
							return IVisitor.CONTINUE_TRAVERSAL;
						}
					});
				}

				if (this instanceof IFeedback)
				{
					((IFeedback)this).updateFeedback();
				}

				// attach
				internalAttach();

				// check authorization
				// first the component itself
				// (after attach as otherwise list views etc wont work)
				setRenderAllowed(isActionAuthorized(RENDER));
				// check children if this is a container
				if (this instanceof MarkupContainer)
				{
					MarkupContainer container = (MarkupContainer)this;
					container.visitChildren(new IVisitor()
					{
						public Object component(final Component component)
						{
							// Find out if this component can be rendered
							final boolean renderAllowed = component.isActionAuthorized(RENDER);
							// Authorize rendering
							component.setRenderAllowed(renderAllowed);
							return IVisitor.CONTINUE_TRAVERSAL;
						}
					});
				}

				// Render the component and all its children
				onBeforeRender();
				render(markupStream);
			}
			finally
			{
				// Make sure the original markup stream is back in place
				parent.setMarkupStream(originalMarkupStream);
				onAfterRender();
			}

			// Component has been rendered
			notifyBehaviorsComponentRendered();
		}
	}

