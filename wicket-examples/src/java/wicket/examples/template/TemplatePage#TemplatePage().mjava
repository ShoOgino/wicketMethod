	/**
	 * Constructor
	 */
	public TemplatePage()
	{
		new Label(this, "title", new PropertyModel(this, "pageTitle"));
		currentBanner = new Banner1(this, "ad");
		new Link(this, "changeAdLink")
		{
			/**
			 * @see wicket.markup.html.link.Link#onClick()
			 */
			@Override
			public void onClick()
			{
				if (currentBanner.getClass() == Banner1.class)
				{
					// we already had a component directly under the page with
					// id 'ad'. Creating a new one like this (same id, same
					// hierarchy position) will have the effect that this new
					// component will be set as the current one, and thus will
					// be rendered instead of the previous child. In Wicket
					// pre 2.0 (before you had to pass in the parent in the
					// constructor to create the hierarchy, and had to use
					// Component#add instead) you achieved the same by calling
					// Component#replace. Now you either construct a new
					// component with the same parent and same id, or - if
					// you have a reference to a component that was previously
					// created with that parent - you call Component#reAttach
					// to set that component as the current one.
					new Banner2(TemplatePage.this, "ad");
				}
				else
				{
					new Banner1(TemplatePage.this, "ad");
				}
			}
		};
		new BookmarkablePageLink(this, "page1Link", Page1.class);
		new BookmarkablePageLink(this, "page2Link", Page2.class);
	}

