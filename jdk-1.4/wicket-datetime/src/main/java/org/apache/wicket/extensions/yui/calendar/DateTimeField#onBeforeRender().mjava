	/**
	 * @see org.apache.wicket.Component#onBeforeRender()
	 */
	protected void onBeforeRender()
	{
		dateField.setRequired(isRequired());
		hoursField.setRequired(isRequired());
		minutesField.setRequired(isRequired());

		dateField.setEnabled(isEnabled() && isEnableAllowed());
		hoursField.setEnabled(isEnabled() && isEnableAllowed());
		minutesField.setEnabled(isEnabled() && isEnableAllowed());
		amOrPmChoice.setEnabled(isEnabled() && isEnableAllowed());

		boolean use12HourFormat = use12HourFormat();
		amOrPmChoice.setVisible(use12HourFormat);

		Date d = (Date)getModelObject();
		if (d != null)
		{
			date = new MutableDateTime(d);
		}
		else
		{
			date = null;
		}

		if (date != null)
		{
			// convert date to the client's time zone if we have that info
			TimeZone zone = getClientTimeZone();
			// instantiate with the previously set date
			if (zone != null)
			{
				date.setZone(DateTimeZone.forTimeZone(zone));
			}

			if (use12HourFormat)
			{
				int hourOfHalfDay = date.get(DateTimeFieldType.hourOfHalfday());
				hours = new Integer(hourOfHalfDay == 0 ? 12 : hourOfHalfDay);
			}
			else
			{
				hours = new Integer(date.get(DateTimeFieldType.hourOfDay()));
			}
			amOrPm = (date.get(DateTimeFieldType.halfdayOfDay()) == 0) ? AM_PM.AM : AM_PM.PM;
			minutes = new Integer(date.getMinuteOfHour());


			// we don't really have to reset the date field to the server's
			// timezone, as it's the same milliseconds from EPOCH anyway, and toDate
			// will always get the Date object initialized for the time zone
			// of the server
		}

		super.onBeforeRender();
	}

