	/**
	 * Sets the converted input, which is an instance of {@link Date}, possibly
	 * null. It combines the inputs of the nested date, hours, minutes and am/pm
	 * fields and constructs a date from it.
	 * <p>
	 * Note that overriding this method is a better option than overriding
	 * {@link #updateModel()} like the first versions of this class did. The
	 * reason for that is that this method can be used by form validators
	 * without having to depend on the actual model being updated, and this
	 * method is called by the default implementation of {@link #updateModel()}
	 * anyway (so we don't have to override that anymore).
	 * </p>
	 * 
	 * @see org.apache.wicket.markup.html.form.FormComponent#convertInput()
	 */
	protected void convertInput()
	{
		Object dateFieldInput = dateField.getConvertedInput();
		if (dateFieldInput != null)
		{
			MutableDateTime date = new MutableDateTime(dateFieldInput);
			Integer hours = (Integer)hoursField.getConvertedInput();
			Integer minutes = (Integer)minutesField.getConvertedInput();
			AM_PM amOrPm = (AM_PM)amOrPmChoice.getConvertedInput();

			try
			{
				TimeZone zone = getClientTimeZone();
				if (zone != null)
				{
					date.setZone(DateTimeZone.forTimeZone(zone));
				}

				if (hours != null)
				{
					date.set(DateTimeFieldType.hourOfHalfday(), hours.intValue() % 12);
					date.setMinuteOfHour((minutes != null) ? minutes.intValue() : 0);
				}
				if (amOrPm == AM_PM.PM)
				{
					date.set(DateTimeFieldType.halfdayOfDay(), 1);
				}
				else
				{
					date.set(DateTimeFieldType.halfdayOfDay(), 0);
				}

				// the date will be in the server's timezone
				setConvertedInput(date.toDate());
			}
			catch (RuntimeException e)
			{
				DateTimeField.this.error(e.getMessage());
				invalid();
			}
		}
		else
		{
			setConvertedInput(null);
		}
	}

