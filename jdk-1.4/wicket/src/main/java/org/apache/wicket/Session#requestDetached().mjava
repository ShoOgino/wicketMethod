	/**
	 * INTERNAL API. The request cycle when detached will call this.
	 * 
	 */
	final void requestDetached()
	{
		List touchedPages = (List)Session.touchedPages.get();
		Session.touchedPages.set(null);
		if (touchedPages != null)
		{
			for (int i = 0; i < touchedPages.size(); i++)
			{
				Page page = (Page)touchedPages.get(i);
				page.getPageMap().put(page);
			}
		}

		// If state is dirty
		if (dirty)
		{
			if (log.isDebugEnabled())
			{
				log.debug("update: Session is dirty.  Replicating.");
			}

			// State is no longer dirty
			this.dirty = false;

			// Set attribute.
			setAttribute(SESSION_ATTRIBUTE_NAME, this);
		}
		else
		{
			if (log.isDebugEnabled())
			{
				log.debug("update: Session not dirty.");
			}
		}

		List dirtyObjects = (List)Session.dirtyObjects.get();
		Session.dirtyObjects.set(null);

		// Go through all dirty entries, replicating any dirty objects
		if (dirtyObjects != null)
		{
			for (final Iterator iterator = dirtyObjects.iterator(); iterator.hasNext();)
			{
				String attribute = null;
				Object object = iterator.next();
				if (object instanceof Page)
				{
					final Page page = (Page)object;
					if (page.isStateless())
					{
						// check, can it be that stateless pages where added to
						// the session?
						// and should be removed now?
						continue;
					}
					attribute = page.getPageMap().attributeForId(page.getNumericId());
					if (getAttribute(attribute) == null)
					{
						// page removed by another thread. don't add it again.
						continue;
					}
					object = page.getPageMapEntry();
				}
				else if (object instanceof IPageMap)
				{
					attribute = attributeForPageMapName(((IPageMap)object).getName());
				}

				setAttribute(attribute, object);
			}
		}

		if (pageMapsUsedInRequest != null)
		{
			synchronized (pageMapsUsedInRequest)
			{
				Thread t = Thread.currentThread();
				Iterator it = pageMapsUsedInRequest.entrySet().iterator();
				while (it.hasNext())
				{
					Entry entry = (Entry)it.next();
					if (((PageMapsUsedInRequestEntry)entry.getValue()).thread == t)
					{
						it.remove();
					}
				}
				pageMapsUsedInRequest.notifyAll();
			}
		}
	}

