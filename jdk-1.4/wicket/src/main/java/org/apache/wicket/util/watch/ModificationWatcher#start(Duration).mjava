	/**
	 * Starts watching at a given <code>Duration</code> polling rate.
	 * 
	 * @param pollFrequency
	 *            the polling rate <code>Duration</code>
	 */
	public void start(final Duration pollFrequency)
	{
		// Construct task with the given polling frequency
		task = new Task("ModificationWatcher");

		task.run(pollFrequency, new ICode()
		{
			public void run(final Logger log)
			{
				// Iterate over a copy of the list of entries to avoid
				// concurrent
				// modification problems without the associated liveness issues
				// of holding a lock while potentially polling file times!
				for (final Iterator iterator = new ArrayList(modifiableToEntry.values()).iterator(); iterator
						.hasNext();)
				{
					// Get next entry
					final Entry entry = (Entry)iterator.next();

					// If the modifiable has been modified after the last known
					// modification time
					final Time modifiableLastModified = entry.modifiable.lastModifiedTime();

					if (modifiableLastModified.after(entry.lastModifiedTime))
					{
						// Notify all listeners that the modifiable was modified
						entry.listeners.notifyListeners();

						// Update timestamp
						entry.lastModifiedTime = modifiableLastModified;
					}
				}
			}
		});
	}

