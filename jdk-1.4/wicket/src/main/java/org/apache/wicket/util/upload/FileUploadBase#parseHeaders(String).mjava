	/**
	 * <p>
	 * Parses the <code>header-part</code> and returns as key/value pairs.
	 * 
	 * <p>
	 * If there are multiple headers of the same names, the name will map to a comma-separated list
	 * containing the values.
	 * 
	 * @param headerPart
	 *            The <code>header-part</code> of the current <code>encapsulation</code>.
	 * 
	 * @return A <code>Map</code> containing the parsed HTTP request headers.
	 */
	protected Map /* String, String */parseHeaders(String headerPart)
	{
		Map headers = new HashMap();
		char[] buffer = new char[MAX_HEADER_SIZE];
		boolean done = false;
		int j = 0;
		int i;
		String header, headerName, headerValue;
		try
		{
			while (!done)
			{
				i = 0;
				// Copy a single line of characters into the buffer,
				// omitting trailing CRLF.
				while (i < 2 || buffer[i - 2] != '\r' || buffer[i - 1] != '\n')
				{
					buffer[i++] = headerPart.charAt(j++);
				}
				header = new String(buffer, 0, i - 2);
				if (header.equals(""))
				{
					done = true;
				}
				else
				{
					if (header.indexOf(':') == -1)
					{
						// This header line is malformed, skip it.
						continue;
					}
					headerName = header.substring(0, header.indexOf(':')).trim().toLowerCase();
					headerValue = header.substring(header.indexOf(':') + 1).trim();
					if (getHeader(headers, headerName) != null)
					{
						// More that one header of that name exists,
						// append to the list.
						headers.put(headerName, getHeader(headers, headerName) + ',' + headerValue);
					}
					else
					{
						headers.put(headerName, headerValue);
					}
				}
			}
		}
		catch (IndexOutOfBoundsException e)
		{
			// Headers were malformed. continue with all that was
			// parsed.
		}
		return headers;
	}

