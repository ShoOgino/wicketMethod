	/**
	 * Gets the next tag from the input string.
	 * 
	 * @return The extracted tag (will always be of type XmlTag).
	 * @throws ParseException
	 */
	public final boolean next() throws ParseException
	{
		// Reached end of markup file?
		if (this.input.getPosition() >= this.input.size())
		{
			return false;
		}

		if (this.skipUntilText != null)
		{
			skipUntil();
			return true;
		}

		// Any more tags in the markup?
		final int openBracketIndex = this.input.find('<');

		// Tag or Body?
		if (this.input.charAt(this.input.getPosition()) != '<')
		{
			if (openBracketIndex == -1)
			{
				// There is no next matching tag.
				this.lastText = this.input.getSubstring(-1);
				this.input.setPosition(this.input.size());
				this.lastType = BODY;
				return true;
			}

			this.lastText = this.input.getSubstring(openBracketIndex);
			this.input.setPosition(openBracketIndex);
			this.lastType = BODY;
			return true;
		}

		// Determine the line number
		this.input.countLinesTo(openBracketIndex);

		// Get index of closing tag and advance past the tag
		int closeBracketIndex = this.input.find('>', openBracketIndex + 1);
		if (closeBracketIndex == -1)
		{
			throw new ParseException("No matching close bracket at position " + openBracketIndex,
					this.input.getPosition());
		}

		// Get the complete tag text
		this.lastText = this.input.getSubstring(openBracketIndex, closeBracketIndex + 1);

		// Get the tagtext between open and close brackets
		String tagText = this.lastText.subSequence(1, this.lastText.length() - 1).toString();
		if (tagText.length() == 0)
		{
			throw new ParseException("Found empty tag: '<>' at position " + openBracketIndex,
					this.input.getPosition());
		}

		// Handle special tags like <!-- and <![CDATA ...
		final char firstChar = tagText.charAt(0);
		if ((firstChar == '!') || (firstChar == '?'))
		{
			specialTagHandling(tagText, openBracketIndex, closeBracketIndex);
			return true;
		}

		// Type of the tag, to be determined next
		final XmlTag.Type type;

		// If the tag ends in '/', it's a "simple" tag like <foo/>
		if (tagText.endsWith("/"))
		{
			type = XmlTag.OPEN_CLOSE;
			tagText = tagText.substring(0, tagText.length() - 1);
		}
		else if (tagText.startsWith("/"))
		{
			// The tag text starts with a '/', it's a simple close tag
			type = XmlTag.CLOSE;
			tagText = tagText.substring(1);
		}
		else
		{
			// It must be an open tag
			type = XmlTag.OPEN;

			// If open tag and starts with "s" like "script" or "style", than
			// ...
			if ((tagText.length() > 5)
					&& ((tagText.charAt(0) == 's') || (tagText.charAt(0) == 'S')))
			{
				final String lowerCase = tagText.substring(0, 6).toLowerCase();
				if (lowerCase.startsWith("script"))
				{
					// prepare to skip everything between the open and close tag
					this.skipUntilText = "script";
				}
				else if (lowerCase.startsWith("style"))
				{
					// prepare to skip everything between the open and close tag
					this.skipUntilText = "style";
				}
			}
		}

		// Parse remaining tag text, obtaining a tag object or null
		// if it's invalid
		this.lastTag = parseTagText(tagText);
		if (this.lastTag != null)
		{
			// Populate tag fields
			this.lastTag.type = type;
			this.lastTag.pos = openBracketIndex;
			this.lastTag.length = this.lastText.length();
			this.lastTag.text = this.lastText;
			this.lastTag.lineNumber = this.input.getLineNumber();
			this.lastTag.columnNumber = this.input.getColumnNumber();

			// Move to position after the tag
			this.input.setPosition(closeBracketIndex + 1);
			this.lastType = TAG;
			return true;
		}
		else
		{
			throw new ParseException("Malformed tag (line " + this.input.getLineNumber()
					+ ", column " + this.input.getColumnNumber() + ")", openBracketIndex);
		}
	}

