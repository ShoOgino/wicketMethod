	/**
	 * Computes the percentagle widths of columns. If a column spans over other
	 * columns, the widths of those columns will be zero.
	 * 
	 * @return widths of columns
	 */
	protected double[] computeColumnWidths()
	{
		// initialize the columns array
		double result[] = new double[columns.size()];
		Arrays.fill(result, 0d);

		// the sum of weights of all columns
		double sum = 0d;
		double whole = 99.8d;

		// go over all columns, check their alignment and count sum of their
		// weights
		for (Iterator i = columns.iterator(); i.hasNext();)
		{
			IColumn column = (IColumn)i.next();
			// check if the unit is right
			if (column.getLocation().getUnit() != Unit.PROPORTIONAL)
			{
				throw new IllegalStateException("Middle columns must have PROPORTIONAL unit set.");
			}
			sum += column.getLocation().getSize();
		}


		int index = 0; // index of currently processed column

		int spanColumn = 0; // index of column that is spanning over currently
		// processed column (if any)
		int spanLeft = 0; // over how many columns does the spanning column
		// span

		for (Iterator i = columns.iterator(); i.hasNext();)
		{
			IColumn column = (IColumn)i.next();
			int ix = index; // to which column should we append the size
			if (spanLeft > 0) // is there a column spanning over current
			// column?
			{
				ix = spanColumn; // the size should be appended to the
				// spanning
				// column
				--spanLeft;
			}
			// add the percentage size to the column
			result[ix] += Math.round((column.getLocation().getSize()) / sum * whole);

			// wants this column to span and no other column is spanning over
			// this column?
			if (spanLeft == 0 && column.getSpan(node) > 1)
			{
				int maxSpan = columns.size() - columns.indexOf(column); // how
				// many
				// columns
				// left
				int span = column.getSpan(node) - 1; // how much columns want
				// the column to span
				// over
				spanColumn = index; // index of column that is spanning
				spanLeft = span < maxSpan ? span : maxSpan; // set the number of
				// columns spanned
				// over
			}
			++index;
		}

		// count the sum
		double together = 0d;

		for (int i = 0; i < result.length; i++)
		{
			together += result[i];
		}

		// is it bigger than 99.8? that can cause layout problems in IE
		if (together > 99.8d)
		{
			// this can happen - rounding error. just decrease the last one
			for (int i = result.length - 1; i >= 0; --i)
			{
				if (result[i] != 0d)
				{
					result[i] -= together - 99.8d;
					break;
				}
			}

		}

		return result;
	}

