	/**
	 * Tests that a <code>Component</code> has been added to a
	 * <code>AjaxRequestTarget</code>, using
	 * {@link AjaxRequestTarget#addComponent(Component)}. This method actually
	 * tests that a <code>Component</code> is on the Ajax response sent back
	 * to the client.
	 * <p>
	 * PLEASE NOTE! This method doesn't actually insert the
	 * <code>Component</code> in the client DOM tree, using Javascript. But it
	 * shouldn't be needed because you have to trust that the Wicket Ajax
	 * Javascript just works.
	 * 
	 * @param component
	 *            the <code>Component</code> to test
	 * @return a <code>Result</code>
	 */
	public Result isComponentOnAjaxResponse(Component component) {
		String failMessage = "A component which is null could not have been added to the AJAX response";
		notNull(failMessage, component);

		// Get the AJAX response
		String ajaxResponse = getServletResponse().getDocument();

		// Test that the previous response was actually a AJAX response
		failMessage = "The Previous response was not an AJAX response. "
				+ "You need to execute an AJAX event, using clickLink, before using this assert";
		boolean isAjaxResponse = ajaxResponse
				.startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?><ajax-response>");
		Result result = isTrue(failMessage, isAjaxResponse);
		if (result.wasFailed()) {
			return result;
		}

		// See if the component has a markup id
		String markupId = component.getMarkupId();

		failMessage = "The component doesn't have a markup id, "
				+ "which means that it can't have been added to the AJAX response";
		result = isTrue(failMessage, !Strings.isEmpty(markupId));
		if (result.wasFailed()) {
			return result;
		}

		// Look for that the component is on the response, using the markup id
		boolean isComponentInAjaxResponse = ajaxResponse
				.matches("(?s).*<component id=\"" + markupId + "\" ?>.*");
		failMessage = "Component wasn't found in the AJAX response";
		return isTrue(failMessage, isComponentInAjaxResponse);
	}

