	/**
	 * Test that a component has been added to a AjaxRequestTarget, using
	 * {@link AjaxRequestTarget#addComponent(Component)}. This method actually
	 * tests that a component is on the AJAX response sent back to the client.
	 * <p>
	 * PLEASE NOTE! This method doesn't actually insert the component in the
	 * client DOM tree, using javascript. But it shouldn't be needed because you
	 * have to trust that the Wicket Ajax Javascript just works.
	 * 
	 * @param component
	 *            The component to test whether it's on the response.
	 * @return
	 */
	public Result isComponentOnAjaxResponse(Component component)
	{
		String failMessage = "A component which is null could not have been added to the AJAX response";
		notNull(failMessage, component);

		// Get the AJAX response
		String ajaxResponse = getServletResponse().getDocument();

		// Test that the previous response was actually a AJAX response
		failMessage = "The Previous response was not an AJAX response. "
				+ "You need to execute an AJAX event, using clickLink, before using this assert";
		boolean isAjaxResponse = ajaxResponse
				.startsWith("<?xml version=\"1.0\" encoding=\"UTF-8\"?><ajax-response>");
		Result result = isTrue(failMessage, isAjaxResponse);
		if (result.wasFailed())
			return result;

		// See if the component has a markup id
		String markupId = component.getMarkupId();

		failMessage = "The component doesn't have a markup id, "
				+ "which means that it can't have been added to the AJAX response";
		result = isTrue(failMessage, !Strings.isEmpty(markupId));
		if (result.wasFailed())
			return result;

		// Look for that the component is on the response, using the markup id
		boolean isComponentInAjaxResponse = ajaxResponse.matches(".*<component id=\"" + markupId
				+ "\" ?>.*");
		failMessage = "Component wasn't found in the AJAX response";
		return isTrue(failMessage, isComponentInAjaxResponse);
	}

