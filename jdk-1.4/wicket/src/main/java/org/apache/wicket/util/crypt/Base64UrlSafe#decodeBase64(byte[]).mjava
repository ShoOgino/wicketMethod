    /**
     * Decodes Base64 data into octects
     *
     * @param base64Data Byte array containing Base64 data
     * @return Array containing decoded data.
     */
    public static byte[] decodeBase64(byte[] base64Data)
    {
        // RFC 2045 requires that we discard ALL non-Base64 characters
        base64Data = discardNonBase64(base64Data);

        // handle the edge case, so we don't have to worry about it later
        if (base64Data.length == 0)
        {
            return new byte[0];
        }

        int numberQuadruple = (base64Data.length + 3) / FOURBYTE;
        byte decodedData[] = new byte[base64Data.length - numberQuadruple];
        byte b1 = 0, b2 = 0, b3 = 0, b4 = 0, marker0 = 0, marker1 = 0;

        // Throw away anything not in base64Data
        int encodedIndex = 0;
        int dataIndex = 0;

        for (int i = 0; i < numberQuadruple; i++)
        {
            dataIndex = i * 4;

            b1 = base64Alphabet[base64Data[dataIndex]];
            b2 = base64Alphabet[base64Data[dataIndex + 1]];

            if ((dataIndex + 3) < base64Data.length)
            {
                //No PAD e.g 3cQl
                b3 = base64Alphabet[base64Data[dataIndex + 2]];
                b4 = base64Alphabet[base64Data[dataIndex + 3]];

                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);
                decodedData[encodedIndex + 1] =
                        (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));
                decodedData[encodedIndex + 2] = (byte) (b3 << 6 | b4);
            }
            else if ((dataIndex + 2) < base64Data.length)
            {
                //One PAD e.g. 3cQ[Pad]
                b3 = base64Alphabet[base64Data[dataIndex + 2]];

                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);
                decodedData[encodedIndex + 1] =
                        (byte) (((b2 & 0xf) << 4) | ((b3 >> 2) & 0xf));
            }
            else if ((dataIndex + 1) < base64Data.length)
            {
                //Two PAD e.g. 3c[Pad][Pad]
                decodedData[encodedIndex] = (byte) (b1 << 2 | b2 >> 4);
            }
            encodedIndex += 3;
        }
        return decodedData;
    }

