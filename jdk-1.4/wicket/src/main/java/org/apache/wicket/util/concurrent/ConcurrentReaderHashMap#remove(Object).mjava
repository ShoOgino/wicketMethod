	/**
	 * Removes the key (and its corresponding value) from this table. This
	 * method does nothing if the key is not in the table.
	 * 
	 * @param key
	 *            the key that needs to be removed.
	 * @return the value to which the key had been mapped in this table, or
	 *         <code>null</code> if the key did not have a mapping.
	 * @exception NullPointerException
	 *                if the key is <code>null</code>.
	 */
	public Object remove(Object key)
	{
		/*
		 * Find the entry, then 1. Set value field to null, to force get() to
		 * retry 2. Rebuild the list without this entry. All entries following
		 * removed node can stay in list, but all preceeding ones need to be
		 * cloned. Traversals rely on this strategy to ensure that elements will
		 * not be repeated during iteration.
		 */

		int hash = hash(key);
		Entry[] tab = table;
		int index = hash & (tab.length - 1);
		Entry first = tab[index];
		Entry e = first;

		for (e = first; e != null; e = e.next)
		{
			if (e.hash == hash && eq(key, e.key))
			{
				break;
			}
		}

		synchronized (this)
		{
			if (tab == table)
			{
				if (e == null)
				{
					if (first == tab[index])
					{
						return null;
					}
				}
				else
				{
					Object oldValue = e.value;
					if (first == tab[index] && oldValue != null)
					{
						e.value = null;
						count--;

						Entry head = e.next;
						for (Entry p = first; p != e; p = p.next)
						{
							head = new Entry(p.hash, p.key, p.value, head);
						}

						tab[index] = head;
						recordModification(head);
						return oldValue;
					}
				}
			}

			// Wrong list or interference
			return sremove(key, hash);
		}
	}

