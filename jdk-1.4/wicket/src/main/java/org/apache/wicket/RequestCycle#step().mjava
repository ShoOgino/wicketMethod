	/**
	 * handle the current step in the request processing.
	 */
	private final void step()
	{
		try
		{
			switch (currentStep)
			{
				case PREPARE_REQUEST : {
					// prepare the request
					prepare();
					break;
				}
				case RESOLVE_TARGET : {
					// resolve the target of the request using the request
					// parameters
					final IRequestTarget target = processor.resolve(this, request
							.getRequestParameters());

					// has to result in a request target
					if (target == null)
					{
						throw new WicketRuntimeException(
								"the processor did not resolve to any request target");
					}
					// Add (inserting at the bottom) in case before or during
					// target resolving one or more request targets were pushed
					// on the stack before this. If that is the case, they
					// should be handled before this
					requestTargets.add(0, target);
					break;
				}
				case PROCESS_EVENTS : {
					processEventsAndRespond();
					break;
				}
				case RESPOND : {
					// generate a response
					respond();
					break;
				}
				default : {
					// nothing
				}
			}
		}
		catch (AbortException e)
		{
			throw e;
		}
		catch (RuntimeException e)
		{
			// set step manually to handle exception
			currentStep = HANDLE_EXCEPTION;

			// probably our last chance the exception can be logged.
			// Note that a PageExpiredException should not be logged, because
			// it's not an internal error
			if (!(e instanceof PageExpiredException))
			{
				logRuntimeException(e);
			}

			// try to play nicely and let the request processor handle the
			// exception response. If that doesn't work, any runtime exception
			// will automatically be bubbled up
			if (processor != null)
			{
				processor.respond(e, this);
			}
		}
	}

