	/**
	 * THIS METHOD IS NOT PART OF THE WICKET PUBLIC API. DO NOT USE IT.
	 * <p>
	 * Renders the component at the current position in the given markup stream. The method
	 * onComponentTag() is called to allow the component to mutate the start tag. The method
	 * onComponentTagBody() is then called to permit the component to render its body.
	 */
	public final void internalRenderComponent()
	{
		final IMarkupFragment markup = getMarkup();
		if (markup == null)
		{
			throw new MarkupException("Markup not found. Component: " + toString());
		}

		final MarkupStream markupStream = new MarkupStream(markup);

		// Get mutable copy of next tag
		final ComponentTag openTag = markupStream.getTag();
		final ComponentTag tag = openTag.mutable();

		// Call any tag handler
		onComponentTag(tag);

		// If we're an openclose tag
		if (!tag.isOpenClose() && !tag.isOpen())
		{
			// We were something other than <tag> or <tag/>
			markupStream.throwMarkupException("Method renderComponent called on bad markup element: " +
				tag);
		}

		if (tag.isOpenClose() && openTag.isOpen())
		{
			markupStream.throwMarkupException("You can not modify a open tag to open-close: " + tag);
		}

		try
		{
			// Render open tag
			boolean renderBodyOnly = getRenderBodyOnly();
			if (renderBodyOnly)
			{
				ExceptionSettings.NotRenderableErrorStrategy notRenderableErrorStrategy = ExceptionSettings.NotRenderableErrorStrategy.LOG_WARNING;
				if (Application.exists())
				{
					notRenderableErrorStrategy = getApplication().getExceptionSettings().getNotRenderableErrorStrategy();
				}

				if (getFlag(FLAG_OUTPUT_MARKUP_ID))
				{
					String message = String.format("Markup id set on a component that renders its body only. " +
					                               "Markup id: %s, component id: %s.", getMarkupId(), getId());
					if (notRenderableErrorStrategy == ExceptionSettings.NotRenderableErrorStrategy.THROW_EXCEPTION)
					{
						throw new IllegalStateException(message);
					}
					log.warn(message);
				}
				if (getFlag(FLAG_PLACEHOLDER))
				{
					String message = String.format("Placeholder tag set on a component that renders its body only. " +
					                               "Component id: %s.", getId());
					if (notRenderableErrorStrategy == ExceptionSettings.NotRenderableErrorStrategy.THROW_EXCEPTION)
					{
						throw new IllegalStateException(message);
					}
					log.warn(message);
				}
			}
			else
			{
				renderComponentTag(tag);
			}
			markupStream.next();

			// Render the body only if open-body-close. Do not render if open-close.
			if (tag.isOpen())
			{
				// Render the body. The default strategy will simply call the component's
				// onComponentTagBody() implementation.
				getMarkupSourcingStrategy().onComponentTagBody(this, markupStream, tag);

				// Render close tag
				if (openTag.isOpen())
				{
					renderClosingComponentTag(markupStream, tag, renderBodyOnly);
				}
				else if (renderBodyOnly == false)
				{
					if (needToRenderTag(openTag))
					{
						// Close the manually opened tag. And since the user might have changed the
						// tag name ...
						getResponse().write(tag.syntheticCloseTagString());
					}
				}
			}
		}
		catch (WicketRuntimeException wre)
		{
			throw wre;
		}
		catch (RuntimeException re)
		{
			throw new WicketRuntimeException("Exception in rendering component: " + this, re);
		}
	}

