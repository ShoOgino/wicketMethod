	/**
	 * Makes a deep clone of an object by serializing and deserializing it. The object must be fully
	 * serializable to be cloned. This method will not clone wicket Components, it will just reuse
	 * those instances so that the complete component tree is not copied over only the model data.
	 *
	 * <strong>Warning</strong>: this method uses Java Serialization APIs to be able to avoid cloning
	 * of {@link org.apache.wicket.Component} instances. If the application uses custom
	 * {@link org.apache.wicket.serialize.ISerializer} then most probably this method cannot be used.
	 *
	 * @param object
	 *            The object to clone
	 * @return A deep copy of the object
	 * @deprecated Use {@linkplain #cloneObject(Object)} instead
	 */
	@Deprecated
	public static <T> T cloneModel(final T object)
	{
		if (object == null)
		{
			return null;
		}
		else
		{
			try
			{
				final ByteArrayOutputStream out = new ByteArrayOutputStream(256);
				final HashMap<String, Component> replacedObjects = Generics.newHashMap();
				ObjectOutputStream oos = new ReplaceObjectOutputStream(out, replacedObjects);
				oos.writeObject(object);
				ObjectInputStream ois = new ReplaceObjectInputStream(new ByteArrayInputStream(
					out.toByteArray()), replacedObjects, object.getClass().getClassLoader());
				return (T) ois.readObject();
			}
			catch (ClassNotFoundException | IOException e)
			{
				throw new WicketRuntimeException("Internal error cloning object", e);
			}
		}
	}

