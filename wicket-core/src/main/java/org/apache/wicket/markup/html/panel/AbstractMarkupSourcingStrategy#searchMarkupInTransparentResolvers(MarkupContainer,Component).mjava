	/**
	 * If the child has not been directly added to the container, but via a
	 * TransparentWebMarkupContainer, then we are in trouble. In general Wicket iterates over the
	 * markup elements and searches for associated components, not the other way around. Because of
	 * TransparentWebMarkupContainer (or more generally resolvers), there is no "synchronous" search
	 * possible.
	 * 
	 * @param container
	 *            the parent container.
	 * @param child
	 *            The component to find the markup for.
	 * @return the markup fragment for the child, or {@code null}.
	 */
	protected IMarkupFragment searchMarkupInTransparentResolvers(final MarkupContainer container,
		final Component child)
	{
		return container.visitChildren(MarkupContainer.class, new IVisitor<MarkupContainer, IMarkupFragment>()
		{
			@Override
			public void component(MarkupContainer resolvingContainer, IVisit<IMarkupFragment> visit)
			{
				if (resolvingContainer instanceof IComponentResolver)
				{
					IMarkupFragment childMarkup = resolvingContainer.getMarkup(child);

					if (childMarkup != null && childMarkup.size() > 0)
					{
						IComponentResolver componentResolver = (IComponentResolver)resolvingContainer;

						MarkupStream stream = new MarkupStream(childMarkup);

						ComponentTag tag = stream.getTag();

						Component resolvedComponent = resolvingContainer.get(tag.getId());
						if (resolvedComponent == null)
						{
							resolvedComponent = componentResolver.resolve(resolvingContainer, stream, tag);
						}

						if (child == resolvedComponent)
						{
							visit.stop(childMarkup);
						}
					}
				}
			}
		});
	}

