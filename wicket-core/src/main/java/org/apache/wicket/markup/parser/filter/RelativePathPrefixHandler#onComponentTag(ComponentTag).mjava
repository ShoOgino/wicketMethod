	@Override
	protected final MarkupElement onComponentTag(ComponentTag tag) throws ParseException
	{
		if (tag.isClose())
		{
			if (isHeadTag(tag))	
			{
				//outside head tag
				insideHead = false;
			}
			
			return tag;
		}

		if (isHeadTag(tag))	
		{
			//inside head tag
			insideHead = true;
		}

		String wicketIdAttr = getWicketNamespace() + ":" + "id";

		// Don't touch any wicket:id component and any auto-components
		if ((tag instanceof WicketTag) || (tag.isAutolinkEnabled() == true)
			|| (tag.getAttributes().get(wicketIdAttr) != null))
		{
			return tag;
		}
		
		// Work out whether we have any attributes that require us to add a
		// behavior that prepends the relative path.
		for (String attrName : attributeNames)
		{
			String attrValue = tag.getAttributes().getString(attrName);
			if ((attrValue != null) && (attrValue.startsWith("/") == false)
				&& (!attrValue.contains(":")) && !(attrValue.startsWith("#")))
			{
				if (tag.getId() == null)
				{
					tag.setId(getWicketRelativePathPrefix(null));
					tag.setAutoComponentTag(true);
					
					/**
					 * https://issues.apache.org/jira/browse/WICKET-5724
					 * Transparent component inside page body must allow 
					 * queued children components.
					 */
					if(!insideHead)
					{
						tag.setAutoComponentFactory(new ComponentTag.IAutoComponentFactory()
						{
							@Override
							public Component newComponent(MarkupContainer container, ComponentTag tag)
							{
								String id = tag.getId() + container.getPage().getAutoIndex();
								tag.setId(id);
	
								return new TransparentWebMarkupContainer(id);
							}
						});	
					}
				}
				tag.addBehavior(RELATIVE_PATH_BEHAVIOR);
				tag.setModified(true);
				break;
			}
		}

		return tag;
	}

