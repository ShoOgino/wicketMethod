	public void testVersionStringInResourceFilename()
	{
		final IResource resource = new IResource()
		{
			public void respond(Attributes attributes)
			{
			}
		};

		final ResourceReference reference =
			new ResourceReference(getClass(), "versioned", Locale.ENGLISH, "style", null)
			{
				@Override
				public IResource getResource()
				{
					return resource;
				}
			};

		FilenameWithStaticVersionResourceCachingStrategy strategy =
			new FilenameWithStaticVersionResourceCachingStrategy("-version-", "foobar");

		INamedParameters params = new PageParameters();
		ResourceUrl url = new ResourceUrl("test.js", params);
		strategy.decorateUrl(url, reference);
		assertEquals("test-version-foobar.js", url.getFileName());
		strategy.undecorateUrl(url);
		assertEquals("test.js", url.getFileName());

		url = new ResourceUrl("test", params);
		strategy.decorateUrl(url, reference);
		assertEquals("test-version-foobar", url.getFileName());
		strategy.undecorateUrl(url);
		assertEquals("test", url.getFileName());

		// this behavior is o.k. since a browser could request an 
		// previous version of the resource. for example we
		// could first have 'test-alpha.txt' which would be later replaced
		// by 'test-beta.txt' but in any case will point to 
		// internal resource 'test.txt'
		url = new ResourceUrl("test-version-older.txt", params);
		strategy.undecorateUrl(url);
		assertEquals("test.txt", url.getFileName());

		// weird but valid
		url = new ResourceUrl("test-version-.txt", params);
		strategy.undecorateUrl(url);
		assertEquals("test.txt", url.getFileName());

		// weird but valid
		url = new ResourceUrl("test-version--------", params);
		strategy.undecorateUrl(url);
		assertEquals("test", url.getFileName());
	}

