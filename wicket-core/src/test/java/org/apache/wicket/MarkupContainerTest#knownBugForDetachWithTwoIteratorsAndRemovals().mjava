	/**
	 * This tests a functional bug in the iterator implementation where you have multiple iterators
	 * traversing the children, a detach happens and one of the iterators removes a child component
	 * before the other iterator has a chance to update its internal state to the new world. This is
	 * a known bug and we expect that this doesn't pose a problem in real world usage.
	 */
	@Test(expected = ConcurrentModificationException.class)
	public void knownBugForDetachWithTwoIteratorsAndRemovals()
	{
		int n = NUMBER_OF_CHILDREN_FOR_A_MAP * 2;

		WebMarkupContainer wmc = new WebMarkupContainer("id");
		addNChildren(wmc, n);

		Iterator<Component> iterator1 = wmc.iterator();
		Iterator<Component> iterator2 = wmc.iterator();

		Random r = new Random();

		for (int i = 0; i < NUMBER_OF_CHILDREN_FOR_A_MAP; i++)
		{
			if (r.nextBoolean())
			{
				iterator1.next();
				iterator1.remove();
			}
			else
			{
				iterator2.next();
				iterator2.remove();
			}
		}
		wmc.detach();
		iterator1.next();
		iterator1.remove();

		// implementation detail that gets in the way of properly solving this exotic use case: at
		// this moment iterator 2 doesn't know that the modification count was reset before the
		// iterator 1 removed the component.
		iterator2.next();

		// code never reaches this point due to the ConcurrentModificationException
	}

