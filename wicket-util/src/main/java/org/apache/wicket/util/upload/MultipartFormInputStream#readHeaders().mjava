	/**
	 * <p>
	 * Reads the <code>header-part</code> of the current <code>encapsulation</code>.
	 * 
	 * <p>
	 * Headers are returned verbatim to the input stream, including the trailing <code>CRLF</code>
	 * marker. Parsing is left to the application.
	 * 
	 * <p>
	 * <strong>TODO</strong> allow limiting maximum header size to protect against abuse.
	 * 
	 * @return The <code>header-part</code> of the current encapsulation.
	 * 
	 * @throws MalformedStreamException
	 *             if the stream ends unexpecetedly.
	 */
	public String readHeaders() throws MalformedStreamException
	{
		int i = 0;
		byte b;
		// to support multi-byte characters
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		int size = 0;
		while (i < HEADER_SEPARATOR.length)
		{
			try
			{
				b = readByte();
			}
			catch (IOException e)
			{
				throw new MalformedStreamException("Stream ended unexpectedly");
			}
			if (++size > HEADER_PART_SIZE_MAX)
			{
				throw new MalformedStreamException("Header section has more than " +
					HEADER_PART_SIZE_MAX + " bytes (maybe it is not properly terminated)");
			}
			if (b == HEADER_SEPARATOR[i])
			{
				i++;
			}
			else
			{
				i = 0;
			}
			baos.write(b);
		}

		String headers = null;
		if (headerEncoding != null)
		{
			try
			{
				headers = baos.toString(headerEncoding);
			}
			catch (UnsupportedEncodingException e)
			{
				// Fall back to platform default if specified encoding is not
				// supported.
				headers = baos.toString();
			}
		}
		else
		{
			headers = baos.toString();
		}

		return headers;
	}

