	/**
	 * Call this method to cause the file cleaner thread to terminate when there are no more objects
	 * being tracked for deletion.
	 * <p>
	 * In a simple environment, you don't need this method as the file cleaner thread will simply
	 * exit when the JVM exits. In a more complex environment, with multiple class loaders (such as
	 * an application server), you should be aware that the file cleaner thread will continue
	 * running even if the class loader it was started from terminates. This can consitute a memory
	 * leak.
	 * <p>
	 * For example, suppose that you have developed a web application, which contains the commons-io
	 * jar file in your WEB-INF/lib directory. In other words, the FileCleaner class is loaded
	 * through the class loader of your web application. If the web application is terminated, but
	 * the servlet container is still running, then the file cleaner thread will still exist, posing
	 * a memory leak.
	 * <p>
	 * This method allows the thread to be terminated. Simply call this method in the resource
	 * cleanup code, such as {@link javax.servlet.ServletContextListener#contextDestroyed}. Once
	 * called, no new objects can be tracked by the file cleaner.
	 */
	public synchronized void exitWhenFinished()
	{
		// synchronized block protects reaper
		exitWhenFinished = true;
		if (reaper != null)
		{
			synchronized (reaper)
			{
				reaper.interrupt();
			}
		}
	}

