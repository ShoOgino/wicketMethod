	/**
	 * Removes the (key, value) pair from this table. This method does nothing
	 * if the key is not in the table, or if the key is associated with a
	 * different value. This method is needed by EntrySet.
	 * 
	 * @param key
	 *            the key that needs to be removed.
	 * @param value
	 *            the associated value. If the value is null, it means "any
	 *            value".
	 * @return the value to which the key had been mapped in this table, or
	 *         <code>null</code> if the key did not have a mapping.
	 * @exception NullPointerException
	 *                if the key is <code>null</code>.
	 */
	protected Object remove(Object key, Object value)
	{
		/*
		 * Find the entry, then 1. Set value field to null, to force get() to
		 * retry 2. Rebuild the list without this entry. All entries following
		 * removed node can stay in list, but all preceeding ones need to be
		 * cloned. Traversals rely on this strategy to ensure that elements will
		 * not be repeated during iteration.
		 */

		int hash = hash(key);
		Segment seg = segments[hash & SEGMENT_MASK];

		synchronized (seg)
		{
			Entry[] tab = table;
			int index = hash & (tab.length - 1);
			Entry first = tab[index];
			Entry e = first;

			for (;;)
			{
				if (e == null)
				{
					return null;
				}
				if (e.hash == hash && eq(key, e.key))
				{
					break;
				}
				e = e.next;
			}

			Object oldValue = e.value;
			if (value != null && !value.equals(oldValue))
			{
				return null;
			}

			e.value = null;

			Entry head = e.next;
			for (Entry p = first; p != e; p = p.next)
			{
				head = new Entry(p.hash, p.key, p.value, head);
			}
			tab[index] = head;
			seg.count--;
			return oldValue;
		}
	}

