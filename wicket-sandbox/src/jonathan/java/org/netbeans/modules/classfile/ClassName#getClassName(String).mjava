    /**
     * Returns the ClassName object referenced by a class
     * type string (field descriptor), as defined in the 
     * JVM Specification, sections 4.3.2 and 4.2.  
     * <P>
     * Basically, the JVM Specification defines a class type 
     * string where the periods ('.') separating
     * a package name are replaced by forward slashes ('/').
     * Not documented in the second edition of the specification
     * is that periods separating inner and outer classes are
     * replaced with dollar signs ('$').  Array classes have one
     * or more left brackets ('[') prepending the class type.
     * For example:
     * <PRE><CODE>
     *   java.lang.String         java/lang/String
     *   java.util.HashMap.Entry  java/util/HashMap$Entry
     *   java.lang.Integer[]      [java/lang/Integer
     *   java.awt.Point[][]       [[java/awt/Point
     * </CODE><PRE>
     * <P>
     * This method also accepts type strings which contain with
     * 'L' and end with ';' characters.  This format is used
     * to reference a class in other type names, such as
     * method arguments.  These two characters are removed from the
     * type string.
     * <P>
     * Because ClassNames are immutable, multiple requests to
     * get the same type string may return identical object
     * references.  This cannot be assumed, however, and the
     * ClassName.equals() method should be used instead of
     * "==" to test for equality.
     *
     * @param classType  the class type string, as defined by the JVM spec.
     * @throws IllegalArgumentException if classType isn't of the correct
     *                   format.
     */
    public static ClassName getClassName(String classType) {
        // A null superclass name is supposed to be null, but may be
        // an empty string depending on the compiler.
        if (classType == null || classType.length() == 0)
	    return null;

        ClassName cn = getCacheEntry(classType);
	if (cn == null)
	    synchronized (cache) {
		cn = getCacheEntry(classType);
		if (cn == null) {
		    // check for valid class type
		    int i = classType.indexOf('L');
		    String _type;
		    char lastChar = classType.charAt(classType.length()-1);
		    if (i != -1 && lastChar == ';') {
                        // remove 'L' and ';' from type
			_type = classType.substring(i+1, classType.length()-1);
                        if (i > 0)
                            // add array prefix
                            _type = classType.substring(0, i) + _type;
			cn = getCacheEntry(_type);
			if (cn != null)
			    return cn;
		    } else {
			_type = classType;
		    }

		    cn = new ClassName(_type);
		    cache.put(_type, new WeakReference(cn));
		}
	    }
	return cn;
    }

