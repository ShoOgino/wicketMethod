	@Override
	protected void populateTreeItem(WebMarkupContainer<TreeNode> item, int level) 
	{	
		final TreeNode node = item.getModelObject();

		int i = 0;
		
		SideColumnsView sideColumns = new SideColumnsView(item, "sideColumns");
		for (Column column: columns)
		{
			if (column.getLocation().getAlignment() == Alignment.LEFT ||
				column.getLocation().getAlignment() == Alignment.RIGHT)
			{
				Component component;
				Renderable renderable = column.createCell(node, level);			
				
				if (renderable == null)
				{
					component = column.createCell(sideColumns, "" + i++, node, level);
				}
				else
				{
					component = null;
				}
				
				sideColumns.addColumn(column, component, renderable);
			}
		}
		
		i = 0;
		
		MiddleColumnsView middleColumns = new MiddleColumnsView(item, "middleColumns");
		for (Column column: columns)
		{
			if (column.getLocation().getAlignment() == Alignment.MIDDLE)
			{
				Component component;
				Renderable renderable = column.createCell(node, level);			
				
				if (renderable == null)
				{
					component = column.createCell(sideColumns, "" + i++, node, level);
				}
				else
				{
					component = null;
				}
				
				middleColumns.addColumn(column, component, renderable);
			}
		}			
		
		// do distinguish between selected and unselected rows we add an behavior
		// that modifies row css class.
		item.add(new AbstractBehavior() {
			@Override
			public void onComponentTag(Component component, ComponentTag tag) {
				super.onComponentTag(component, tag);
				if (getTreeState().isNodeSelected(node))
					tag.put("class", "row-selected");
				else
					tag.put("class", "row");
			}
		});		
	}

